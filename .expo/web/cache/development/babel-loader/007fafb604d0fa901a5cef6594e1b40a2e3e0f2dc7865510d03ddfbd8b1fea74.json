{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { CardanoAPIService } from \"./CardanoAPIService\";\nimport { NFTManagementService } from \"./NFTManagementService\";\nimport { DeFiStakingService } from \"./DeFiStakingService\";\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nexport var PortfolioAnalyticsService = function () {\n  function PortfolioAnalyticsService() {\n    _classCallCheck(this, PortfolioAnalyticsService);\n    this.cardanoAPI = CardanoAPIService.getInstance();\n    this.nftService = NFTManagementService.getInstance();\n    this.stakingService = DeFiStakingService.getInstance();\n  }\n  return _createClass(PortfolioAnalyticsService, [{\n    key: \"getPortfolioSummary\",\n    value: (function () {\n      var _getPortfolioSummary = _asyncToGenerator(function* (address) {\n        try {\n          console.log('Getting portfolio summary for address:', address);\n          var _yield$Promise$all = yield Promise.all([this.getADABalance(address), this.nftService.getAddressNFTs(address), this.getTokenBalances(address), this.stakingService.getStakingPositions(address), this.stakingService.getLiquidityPositions(address)]),\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 5),\n            adaBalance = _yield$Promise$all2[0],\n            nfts = _yield$Promise$all2[1],\n            tokens = _yield$Promise$all2[2],\n            stakingPositions = _yield$Promise$all2[3],\n            liquidityPositions = _yield$Promise$all2[4];\n          var adaValue = adaBalance * this.getADAPrice();\n          var nftValue = this.calculateNFTValue(nfts);\n          var tokenValue = this.calculateTokenValue(tokens);\n          var lpValue = this.calculateLiquidityValue(liquidityPositions);\n          var stakingValue = this.calculateStakingValue(stakingPositions);\n          var rewardsValue = yield this.calculateTotalRewards(address);\n          var totalValue = adaValue + nftValue + tokenValue + lpValue + stakingValue + rewardsValue;\n          var totalChange24h = yield this.calculatePortfolioChange(address, 1);\n          var totalChange7d = yield this.calculatePortfolioChange(address, 7);\n          var totalChange30d = yield this.calculatePortfolioChange(address, 30);\n          var summary = {\n            totalValue: totalValue,\n            totalChange24h: totalChange24h,\n            totalChange7d: totalChange7d,\n            totalChange30d: totalChange30d,\n            adaValue: adaValue,\n            nftValue: nftValue,\n            tokenValue: tokenValue,\n            lpValue: lpValue,\n            stakingValue: stakingValue,\n            rewardsValue: rewardsValue,\n            lastUpdated: new Date()\n          };\n          yield this.cachePortfolioSummary(address, summary);\n          return summary;\n        } catch (error) {\n          console.error('Failed to get portfolio summary:', error);\n          throw new Error(`Failed to get portfolio summary: ${error}`);\n        }\n      });\n      function getPortfolioSummary(_x) {\n        return _getPortfolioSummary.apply(this, arguments);\n      }\n      return getPortfolioSummary;\n    }())\n  }, {\n    key: \"getPortfolioAssets\",\n    value: (function () {\n      var _getPortfolioAssets = _asyncToGenerator(function* (address) {\n        var _this = this;\n        try {\n          var _yield$Promise$all3 = yield Promise.all([this.getADABalance(address), this.nftService.getAddressNFTs(address), this.getTokenBalances(address), this.stakingService.getStakingPositions(address), this.stakingService.getLiquidityPositions(address)]),\n            _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 5),\n            adaBalance = _yield$Promise$all4[0],\n            nfts = _yield$Promise$all4[1],\n            tokens = _yield$Promise$all4[2],\n            stakingPositions = _yield$Promise$all4[3],\n            liquidityPositions = _yield$Promise$all4[4];\n          var assets = [];\n          if (adaBalance > 0) {\n            var adaPrice = this.getADAPrice();\n            assets.push({\n              id: 'ada',\n              assetId: 'ada',\n              name: 'Cardano',\n              symbol: 'ADA',\n              type: 'ada',\n              quantity: adaBalance.toString(),\n              price: adaPrice,\n              value: adaBalance * adaPrice,\n              change24h: this.getADAChange24h(),\n              change7d: this.getADAChange7d(),\n              change30d: this.getADAChange30d(),\n              allocation: 0,\n              lastUpdated: new Date()\n            });\n          }\n          nfts.forEach(function (nft) {\n            var _nft$metadata;\n            var nftValue = _this.estimateNFTValue(nft);\n            assets.push({\n              id: nft.id,\n              assetId: nft.assetId,\n              name: ((_nft$metadata = nft.metadata) == null ? void 0 : _nft$metadata.name) || 'Unknown NFT',\n              symbol: 'NFT',\n              type: 'nft',\n              quantity: nft.quantity,\n              price: nftValue,\n              value: nftValue * parseFloat(nft.quantity),\n              change24h: 0,\n              change7d: 0,\n              change30d: 0,\n              allocation: 0,\n              lastUpdated: new Date()\n            });\n          });\n          tokens.forEach(function (token) {\n            var tokenPrice = _this.getTokenPrice(token.symbol);\n            assets.push({\n              id: token.id,\n              assetId: token.assetId,\n              name: token.name,\n              symbol: token.symbol,\n              type: 'token',\n              quantity: token.quantity,\n              price: tokenPrice,\n              value: tokenPrice * parseFloat(token.quantity),\n              change24h: _this.getTokenChange24h(token.symbol),\n              change7d: _this.getTokenChange7d(token.symbol),\n              change30d: _this.getTokenChange30d(token.symbol),\n              allocation: 0,\n              lastUpdated: new Date()\n            });\n          });\n          stakingPositions.forEach(function (position) {\n            assets.push({\n              id: position.id,\n              assetId: `staking_${position.poolId}`,\n              name: `Staking in ${position.poolName}`,\n              symbol: 'ADA',\n              type: 'ada',\n              quantity: position.amount,\n              price: _this.getADAPrice(),\n              value: parseFloat(position.amount) * _this.getADAPrice(),\n              change24h: _this.getADAChange24h(),\n              change7d: _this.getADAChange7d(),\n              change30d: _this.getADAChange30d(),\n              allocation: 0,\n              lastUpdated: new Date()\n            });\n          });\n          liquidityPositions.forEach(function (position) {\n            var lpValue = _this.calculateLiquidityPositionValue(position);\n            assets.push({\n              id: position.id,\n              assetId: `lp_${position.poolId}`,\n              name: `LP ${position.poolName}`,\n              symbol: 'LP',\n              type: 'lp_token',\n              quantity: position.liquidityTokens,\n              price: lpValue / parseFloat(position.liquidityTokens || '1'),\n              value: lpValue,\n              change24h: 0,\n              change7d: 0,\n              change30d: 0,\n              allocation: 0,\n              lastUpdated: new Date()\n            });\n          });\n          var totalValue = assets.reduce(function (sum, asset) {\n            return sum + asset.value;\n          }, 0);\n          assets.forEach(function (asset) {\n            asset.allocation = totalValue > 0 ? asset.value / totalValue * 100 : 0;\n          });\n          return assets;\n        } catch (error) {\n          console.error('Failed to get portfolio assets:', error);\n          throw new Error(`Failed to get portfolio assets: ${error}`);\n        }\n      });\n      function getPortfolioAssets(_x2) {\n        return _getPortfolioAssets.apply(this, arguments);\n      }\n      return getPortfolioAssets;\n    }())\n  }, {\n    key: \"getPortfolioPerformance\",\n    value: (function () {\n      var _getPortfolioPerformance = _asyncToGenerator(function* (address) {\n        var days = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n        try {\n          var performance = [];\n          var endDate = new Date();\n          var startDate = new Date(endDate.getTime() - days * 24 * 60 * 60 * 1000);\n          for (var i = 0; i <= days; i++) {\n            var date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);\n            var value = yield this.getHistoricalPortfolioValue(address, date);\n            var previousValue = i > 0 ? yield this.getHistoricalPortfolioValue(address, new Date(date.getTime() - 24 * 60 * 60 * 1000)) : value;\n            var change = value - previousValue;\n            var changePercent = previousValue > 0 ? change / previousValue * 100 : 0;\n            performance.push({\n              date: date,\n              value: value,\n              change: change,\n              changePercent: changePercent\n            });\n          }\n          return performance;\n        } catch (error) {\n          console.error('Failed to get portfolio performance:', error);\n          return [];\n        }\n      });\n      function getPortfolioPerformance(_x3) {\n        return _getPortfolioPerformance.apply(this, arguments);\n      }\n      return getPortfolioPerformance;\n    }())\n  }, {\n    key: \"getTransactionAnalytics\",\n    value: (function () {\n      var _getTransactionAnalytics = _asyncToGenerator(function* (address) {\n        try {\n          var transactions = yield this.cardanoAPI.getAddressTransactions(address);\n          var totalVolume = transactions.reduce(function (sum, tx) {\n            var amount = tx.amount || '0';\n            return sum + parseFloat(amount);\n          }, 0);\n          var feesPaid = transactions.reduce(function (sum, tx) {\n            var fee = tx.fee || '0';\n            return sum + parseFloat(fee);\n          }, 0);\n          var transactionCount = transactions.length;\n          var recipientMap = new Map();\n          transactions.forEach(function (tx) {\n            var to = tx.to;\n            if (to && to !== address) {\n              var current = recipientMap.get(to) || {\n                count: 0,\n                volume: 0\n              };\n              current.count += 1;\n              var amount = tx.amount || '0';\n              current.volume += parseFloat(amount);\n              recipientMap.set(to, current);\n            }\n          });\n          var dailyVolume = new Map();\n          transactions.forEach(function (tx) {\n            var timestamp = tx.timestamp || tx.block_time;\n            if (timestamp) {\n              var txDate = new Date(timestamp);\n              var dateKey = txDate.toISOString().split('T')[0];\n              var dayTransactions = transactions.filter(function (t) {\n                var tTimestamp = t.timestamp || t.block_time;\n                if (tTimestamp) {\n                  var tDate = new Date(tTimestamp);\n                  return tDate.toISOString().split('T')[0] === dateKey;\n                }\n                return false;\n              });\n              var volume = dayTransactions.reduce(function (sum, t) {\n                var amount = t.amount || '0';\n                return sum + parseFloat(amount);\n              }, 0);\n              dailyVolume.set(dateKey, volume);\n            }\n          });\n          var rewardsEarned = yield this.calculateTotalRewards(address);\n          var mostFrequentRecipients = Array.from(recipientMap.entries()).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              address = _ref2[0],\n              data = _ref2[1];\n            return _objectSpread({\n              address: address\n            }, data);\n          }).sort(function (a, b) {\n            return b.count - a.count;\n          }).slice(0, 10);\n          var trends = [];\n          var thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n          for (var i = 0; i < 30; i++) {\n            var date = new Date(thirtyDaysAgo.getTime() + i * 24 * 60 * 60 * 1000);\n            var dateKey = date.toISOString().split('T')[0];\n            var count = dailyVolume.get(dateKey) || 0;\n            var volume = dailyVolume.get(dateKey) || 0;\n            trends.push({\n              date: date,\n              count: count,\n              volume: volume\n            });\n          }\n          return {\n            totalTransactions: transactionCount,\n            totalVolume: totalVolume,\n            averageTransactionSize: transactionCount > 0 ? totalVolume / transactionCount : 0,\n            mostFrequentRecipients: mostFrequentRecipients,\n            transactionTrends: trends,\n            feesPaid: feesPaid,\n            rewardsEarned: rewardsEarned\n          };\n        } catch (error) {\n          console.error('Failed to get transaction analytics:', error);\n          throw new Error(`Failed to get transaction analytics: ${error}`);\n        }\n      });\n      function getTransactionAnalytics(_x4) {\n        return _getTransactionAnalytics.apply(this, arguments);\n      }\n      return getTransactionAnalytics;\n    }())\n  }, {\n    key: \"getStakingAnalytics\",\n    value: (function () {\n      var _getStakingAnalytics = _asyncToGenerator(function* (address) {\n        try {\n          var stakingPositions = yield this.stakingService.getStakingPositions(address);\n          var totalStaked = stakingPositions.reduce(function (sum, pos) {\n            return sum + parseFloat(pos.amount);\n          }, 0);\n          var totalRewards = stakingPositions.reduce(function (sum, pos) {\n            return sum + parseFloat(pos.rewards);\n          }, 0);\n          var totalAPY = stakingPositions.reduce(function (sum, pos) {\n            return sum + 5.5;\n          }, 0);\n          var averageAPY = stakingPositions.length > 0 ? totalAPY / stakingPositions.length : 0;\n          var topPools = stakingPositions.map(function (pos) {\n            return {\n              poolId: pos.poolId,\n              name: pos.poolName,\n              amount: parseFloat(pos.amount),\n              rewards: parseFloat(pos.rewards),\n              apy: 5.5\n            };\n          }).sort(function (a, b) {\n            return b.amount - a.amount;\n          }).slice(0, 5);\n          var stakingHistory = [];\n          var startDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);\n          for (var i = 0; i < 90; i += 7) {\n            var date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);\n            var staked = totalStaked * (0.5 + i / 90 * 0.5);\n            var rewards = totalRewards * (i / 90);\n            stakingHistory.push({\n              date: date,\n              staked: staked,\n              rewards: rewards\n            });\n          }\n          return {\n            totalStaked: totalStaked,\n            totalRewards: totalRewards,\n            averageAPY: averageAPY,\n            topPools: topPools,\n            stakingHistory: stakingHistory\n          };\n        } catch (error) {\n          console.error('Failed to get staking analytics:', error);\n          throw new Error(`Failed to get staking analytics: ${error}`);\n        }\n      });\n      function getStakingAnalytics(_x5) {\n        return _getStakingAnalytics.apply(this, arguments);\n      }\n      return getStakingAnalytics;\n    }())\n  }, {\n    key: \"getNFTCollectionAnalytics\",\n    value: (function () {\n      var _getNFTCollectionAnalytics = _asyncToGenerator(function* (address) {\n        var _this2 = this;\n        try {\n          var nfts = yield this.nftService.getAddressNFTs(address);\n          var totalNFTs = nfts.length;\n          var totalValue = this.calculateNFTValue(nfts);\n          var averageValue = totalNFTs > 0 ? totalValue / totalNFTs : 0;\n          var collectionMap = new Map();\n          nfts.forEach(function (nft) {\n            var current = collectionMap.get(nft.policyId) || {\n              count: 0,\n              value: 0\n            };\n            current.count++;\n            current.value += _this2.estimateNFTValue(nft);\n            collectionMap.set(nft.policyId, current);\n          });\n          var topCollections = Array.from(collectionMap.entries()).map(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n              policyId = _ref4[0],\n              data = _ref4[1];\n            return _objectSpread({\n              policyId: policyId,\n              name: `Collection ${policyId.slice(0, 8)}`\n            }, data);\n          }).sort(function (a, b) {\n            return b.value - a.value;\n          }).slice(0, 10);\n          var recentMints = nfts.filter(function (nft) {\n            return nft.createdAt > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n          }).map(function (nft) {\n            var _nft$metadata2;\n            return {\n              assetId: nft.assetId,\n              name: ((_nft$metadata2 = nft.metadata) == null ? void 0 : _nft$metadata2.name) || 'Unknown NFT',\n              value: _this2.estimateNFTValue(nft),\n              date: nft.createdAt\n            };\n          }).sort(function (a, b) {\n            return b.date.getTime() - a.date.getTime();\n          }).slice(0, 10);\n          var floorPrices = Array.from(collectionMap.keys()).map(function (policyId) {\n            return {\n              policyId: policyId,\n              floorPrice: Math.random() * 100 + 10,\n              lastUpdated: new Date()\n            };\n          });\n          return {\n            totalNFTs: totalNFTs,\n            totalValue: totalValue,\n            averageValue: averageValue,\n            topCollections: topCollections,\n            recentMints: recentMints,\n            floorPrices: floorPrices\n          };\n        } catch (error) {\n          console.error('Failed to get NFT collection analytics:', error);\n          throw new Error(`Failed to get NFT collection analytics: ${error}`);\n        }\n      });\n      function getNFTCollectionAnalytics(_x6) {\n        return _getNFTCollectionAnalytics.apply(this, arguments);\n      }\n      return getNFTCollectionAnalytics;\n    }())\n  }, {\n    key: \"getRiskMetrics\",\n    value: (function () {\n      var _getRiskMetrics = _asyncToGenerator(function* (address) {\n        try {\n          var performance = yield this.getPortfolioPerformance(address, 90);\n          if (performance.length < 2) {\n            return {\n              volatility: 0,\n              sharpeRatio: 0,\n              maxDrawdown: 0,\n              beta: 1,\n              correlation: 0\n            };\n          }\n          var returns = performance.slice(1).map(function (p, i) {\n            var prev = performance[i];\n            return prev.value > 0 ? (p.value - prev.value) / prev.value : 0;\n          });\n          var meanReturn = returns.reduce(function (sum, r) {\n            return sum + r;\n          }, 0) / returns.length;\n          var variance = returns.reduce(function (sum, r) {\n            return sum + Math.pow(r - meanReturn, 2);\n          }, 0) / returns.length;\n          var volatility = Math.sqrt(variance);\n          var riskFreeRate = 0.02;\n          var sharpeRatio = (meanReturn - riskFreeRate / 365) / volatility;\n          var maxDrawdown = 0;\n          var peak = performance[0].value;\n          performance.forEach(function (p) {\n            if (p.value > peak) {\n              peak = p.value;\n            }\n            var drawdown = (peak - p.value) / peak;\n            if (drawdown > maxDrawdown) {\n              maxDrawdown = drawdown;\n            }\n          });\n          var beta = 1;\n          var correlation = 0.8;\n          return {\n            volatility: volatility,\n            sharpeRatio: sharpeRatio,\n            maxDrawdown: maxDrawdown,\n            beta: beta,\n            correlation: correlation\n          };\n        } catch (error) {\n          console.error('Failed to get risk metrics:', error);\n          return {\n            volatility: 0,\n            sharpeRatio: 0,\n            maxDrawdown: 0,\n            beta: 1,\n            correlation: 0\n          };\n        }\n      });\n      function getRiskMetrics(_x7) {\n        return _getRiskMetrics.apply(this, arguments);\n      }\n      return getRiskMetrics;\n    }())\n  }, {\n    key: \"getADABalance\",\n    value: function () {\n      var _getADABalance = _asyncToGenerator(function* (address) {\n        try {\n          var balance = yield this.cardanoAPI.getAddressBalance(address);\n          return parseFloat(balance) / 1000000;\n        } catch (error) {\n          console.error('Failed to get ADA balance:', error);\n          return 0;\n        }\n      });\n      function getADABalance(_x8) {\n        return _getADABalance.apply(this, arguments);\n      }\n      return getADABalance;\n    }()\n  }, {\n    key: \"getTokenBalances\",\n    value: function () {\n      var _getTokenBalances = _asyncToGenerator(function* (address) {\n        try {\n          var assets = yield this.cardanoAPI.getAddressAssets(address);\n          return assets.filter(function (asset) {\n            return asset.quantity !== '1' && asset.asset_name;\n          }).map(function (asset) {\n            return {\n              id: asset.asset,\n              assetId: asset.asset,\n              name: asset.asset_name || 'Unknown Token',\n              symbol: asset.asset_name || 'UNKNOWN',\n              quantity: asset.quantity\n            };\n          });\n        } catch (error) {\n          console.error('Failed to get token balances:', error);\n          return [];\n        }\n      });\n      function getTokenBalances(_x9) {\n        return _getTokenBalances.apply(this, arguments);\n      }\n      return getTokenBalances;\n    }()\n  }, {\n    key: \"getADAPrice\",\n    value: function getADAPrice() {\n      return 0.65;\n    }\n  }, {\n    key: \"getADAChange24h\",\n    value: function getADAChange24h() {\n      return 2.5;\n    }\n  }, {\n    key: \"getADAChange7d\",\n    value: function getADAChange7d() {\n      return -1.2;\n    }\n  }, {\n    key: \"getADAChange30d\",\n    value: function getADAChange30d() {\n      return 8.7;\n    }\n  }, {\n    key: \"getTokenPrice\",\n    value: function getTokenPrice(symbol) {\n      var prices = {\n        'AGIX': 0.25,\n        'MIN': 0.15,\n        'SUNDAE': 0.08\n      };\n      return prices[symbol] || 0.01;\n    }\n  }, {\n    key: \"getTokenChange24h\",\n    value: function getTokenChange24h(symbol) {\n      return Math.random() * 10 - 5;\n    }\n  }, {\n    key: \"getTokenChange7d\",\n    value: function getTokenChange7d(symbol) {\n      return Math.random() * 20 - 10;\n    }\n  }, {\n    key: \"getTokenChange30d\",\n    value: function getTokenChange30d(symbol) {\n      return Math.random() * 40 - 20;\n    }\n  }, {\n    key: \"calculateNFTValue\",\n    value: function calculateNFTValue(nfts) {\n      var _this3 = this;\n      return nfts.reduce(function (sum, nft) {\n        return sum + _this3.estimateNFTValue(nft);\n      }, 0);\n    }\n  }, {\n    key: \"estimateNFTValue\",\n    value: function estimateNFTValue(nft) {\n      return Math.random() * 100 + 10;\n    }\n  }, {\n    key: \"calculateTokenValue\",\n    value: function calculateTokenValue(tokens) {\n      var _this4 = this;\n      return tokens.reduce(function (sum, token) {\n        var price = _this4.getTokenPrice(token.symbol);\n        return sum + price * parseFloat(token.quantity);\n      }, 0);\n    }\n  }, {\n    key: \"calculateLiquidityValue\",\n    value: function calculateLiquidityValue(positions) {\n      var _this5 = this;\n      return positions.reduce(function (sum, pos) {\n        return sum + _this5.calculateLiquidityPositionValue(pos);\n      }, 0);\n    }\n  }, {\n    key: \"calculateLiquidityPositionValue\",\n    value: function calculateLiquidityPositionValue(position) {\n      return parseFloat(position.tokenAAmount || '0') * this.getADAPrice() * 2;\n    }\n  }, {\n    key: \"calculateStakingValue\",\n    value: function calculateStakingValue(positions) {\n      return positions.reduce(function (sum, pos) {\n        return sum + parseFloat(pos.amount);\n      }, 0) * this.getADAPrice();\n    }\n  }, {\n    key: \"calculateTotalRewards\",\n    value: function () {\n      var _calculateTotalRewards = _asyncToGenerator(function* (address) {\n        try {\n          var stakingPositions = yield this.stakingService.getStakingPositions(address);\n          return stakingPositions.reduce(function (sum, pos) {\n            return sum + parseFloat(pos.rewards || '0');\n          }, 0);\n        } catch (error) {\n          return 0;\n        }\n      });\n      function calculateTotalRewards(_x0) {\n        return _calculateTotalRewards.apply(this, arguments);\n      }\n      return calculateTotalRewards;\n    }()\n  }, {\n    key: \"calculatePortfolioChange\",\n    value: function () {\n      var _calculatePortfolioChange = _asyncToGenerator(function* (address, days) {\n        try {\n          var currentValue = yield this.getPortfolioSummary(address);\n          var pastDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n          var pastValue = yield this.getHistoricalPortfolioValue(address, pastDate);\n          return pastValue > 0 ? (currentValue.totalValue - pastValue) / pastValue * 100 : 0;\n        } catch (error) {\n          return 0;\n        }\n      });\n      function calculatePortfolioChange(_x1, _x10) {\n        return _calculatePortfolioChange.apply(this, arguments);\n      }\n      return calculatePortfolioChange;\n    }()\n  }, {\n    key: \"getHistoricalPortfolioValue\",\n    value: function () {\n      var _getHistoricalPortfolioValue = _asyncToGenerator(function* (address, date) {\n        var baseValue = 10000;\n        var timeFactor = (Date.now() - date.getTime()) / (30 * 24 * 60 * 60 * 1000);\n        return baseValue * (1 + timeFactor * 0.01);\n      });\n      function getHistoricalPortfolioValue(_x11, _x12) {\n        return _getHistoricalPortfolioValue.apply(this, arguments);\n      }\n      return getHistoricalPortfolioValue;\n    }()\n  }, {\n    key: \"cachePortfolioSummary\",\n    value: function () {\n      var _cachePortfolioSummary = _asyncToGenerator(function* (address, summary) {\n        try {\n          yield AsyncStorage.setItem(`portfolio_summary_${address}`, JSON.stringify(summary));\n        } catch (error) {\n          console.error('Failed to cache portfolio summary:', error);\n        }\n      });\n      function cachePortfolioSummary(_x13, _x14) {\n        return _cachePortfolioSummary.apply(this, arguments);\n      }\n      return cachePortfolioSummary;\n    }()\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!PortfolioAnalyticsService.instance) {\n        PortfolioAnalyticsService.instance = new PortfolioAnalyticsService();\n      }\n      return PortfolioAnalyticsService.instance;\n    }\n  }]);\n}();","map":{"version":3,"names":["CardanoAPIService","NFTManagementService","DeFiStakingService","AsyncStorage","PortfolioAnalyticsService","_classCallCheck","cardanoAPI","getInstance","nftService","stakingService","_createClass","key","value","_getPortfolioSummary","_asyncToGenerator","address","console","log","_yield$Promise$all","Promise","all","getADABalance","getAddressNFTs","getTokenBalances","getStakingPositions","getLiquidityPositions","_yield$Promise$all2","_slicedToArray","adaBalance","nfts","tokens","stakingPositions","liquidityPositions","adaValue","getADAPrice","nftValue","calculateNFTValue","tokenValue","calculateTokenValue","lpValue","calculateLiquidityValue","stakingValue","calculateStakingValue","rewardsValue","calculateTotalRewards","totalValue","totalChange24h","calculatePortfolioChange","totalChange7d","totalChange30d","summary","lastUpdated","Date","cachePortfolioSummary","error","Error","getPortfolioSummary","_x","apply","arguments","_getPortfolioAssets","_this","_yield$Promise$all3","_yield$Promise$all4","assets","adaPrice","push","id","assetId","name","symbol","type","quantity","toString","price","change24h","getADAChange24h","change7d","getADAChange7d","change30d","getADAChange30d","allocation","forEach","nft","_nft$metadata","estimateNFTValue","metadata","parseFloat","token","tokenPrice","getTokenPrice","getTokenChange24h","getTokenChange7d","getTokenChange30d","position","poolId","poolName","amount","calculateLiquidityPositionValue","liquidityTokens","reduce","sum","asset","getPortfolioAssets","_x2","_getPortfolioPerformance","days","length","undefined","performance","endDate","startDate","getTime","i","date","getHistoricalPortfolioValue","previousValue","change","changePercent","getPortfolioPerformance","_x3","_getTransactionAnalytics","transactions","getAddressTransactions","totalVolume","tx","feesPaid","fee","transactionCount","recipientMap","Map","to","current","get","count","volume","set","dailyVolume","timestamp","block_time","txDate","dateKey","toISOString","split","dayTransactions","filter","t","tTimestamp","tDate","rewardsEarned","mostFrequentRecipients","Array","from","entries","map","_ref","_ref2","data","_objectSpread","sort","a","b","slice","trends","thirtyDaysAgo","now","totalTransactions","averageTransactionSize","transactionTrends","getTransactionAnalytics","_x4","_getStakingAnalytics","totalStaked","pos","totalRewards","rewards","totalAPY","averageAPY","topPools","apy","stakingHistory","staked","getStakingAnalytics","_x5","_getNFTCollectionAnalytics","_this2","totalNFTs","averageValue","collectionMap","policyId","topCollections","_ref3","_ref4","recentMints","createdAt","_nft$metadata2","floorPrices","keys","floorPrice","Math","random","getNFTCollectionAnalytics","_x6","_getRiskMetrics","volatility","sharpeRatio","maxDrawdown","beta","correlation","returns","p","prev","meanReturn","r","variance","pow","sqrt","riskFreeRate","peak","drawdown","getRiskMetrics","_x7","_getADABalance","balance","getAddressBalance","_x8","_getTokenBalances","getAddressAssets","asset_name","_x9","prices","_this3","_this4","positions","_this5","tokenAAmount","_calculateTotalRewards","_x0","_calculatePortfolioChange","currentValue","pastDate","pastValue","_x1","_x10","_getHistoricalPortfolioValue","baseValue","timeFactor","_x11","_x12","_cachePortfolioSummary","setItem","JSON","stringify","_x13","_x14","instance"],"sources":["/Users/sonson/Documents/code/venera/X150-Valkyrie/src/services/PortfolioAnalyticsService.ts"],"sourcesContent":["import { CardanoAPIService } from './CardanoAPIService';\nimport { NFTManagementService } from './NFTManagementService';\nimport { DeFiStakingService } from './DeFiStakingService';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport interface PortfolioAsset {\n    id: string;\n    assetId: string;\n    name: string;\n    symbol: string;\n    type: 'ada' | 'nft' | 'token' | 'lp_token';\n    quantity: string;\n    price: number;\n    value: number;\n    change24h: number;\n    change7d: number;\n    change30d: number;\n    allocation: number;\n    lastUpdated: Date;\n}\n\nexport interface PortfolioSummary {\n    totalValue: number;\n    totalChange24h: number;\n    totalChange7d: number;\n    totalChange30d: number;\n    adaValue: number;\n    nftValue: number;\n    tokenValue: number;\n    lpValue: number;\n    stakingValue: number;\n    rewardsValue: number;\n    lastUpdated: Date;\n}\n\nexport interface PortfolioPerformance {\n    date: Date;\n    value: number;\n    change: number;\n    changePercent: number;\n}\n\nexport interface TransactionAnalytics {\n    totalTransactions: number;\n    totalVolume: number;\n    averageTransactionSize: number;\n    mostFrequentRecipients: Array<{ address: string; count: number; volume: number }>;\n    transactionTrends: Array<{ date: Date; count: number; volume: number }>;\n    feesPaid: number;\n    rewardsEarned: number;\n}\n\nexport interface StakingAnalytics {\n    totalStaked: number;\n    totalRewards: number;\n    averageAPY: number;\n    topPools: Array<{ poolId: string; name: string; amount: number; rewards: number; apy: number }>;\n    stakingHistory: Array<{ date: Date; staked: number; rewards: number }>;\n}\n\nexport interface NFTCollectionAnalytics {\n    totalNFTs: number;\n    totalValue: number;\n    averageValue: number;\n    topCollections: Array<{ policyId: string; name: string; count: number; value: number }>;\n    recentMints: Array<{ assetId: string; name: string; value: number; date: Date }>;\n    floorPrices: Array<{ policyId: string; floorPrice: number; lastUpdated: Date }>;\n}\n\nexport interface RiskMetrics {\n    volatility: number;\n    sharpeRatio: number;\n    maxDrawdown: number;\n    beta: number;\n    correlation: number;\n}\n\n/**\n * Service quản lý Portfolio và Analytics\n * Cung cấp insights về hiệu suất, phân tích rủi ro, và báo cáo chi tiết\n */\nexport class PortfolioAnalyticsService {\n    private static instance: PortfolioAnalyticsService;\n    private cardanoAPI: CardanoAPIService;\n    private nftService: NFTManagementService;\n    private stakingService: DeFiStakingService;\n\n    constructor() {\n        this.cardanoAPI = CardanoAPIService.getInstance();\n        this.nftService = NFTManagementService.getInstance();\n        this.stakingService = DeFiStakingService.getInstance();\n    }\n\n    static getInstance(): PortfolioAnalyticsService {\n        if (!PortfolioAnalyticsService.instance) {\n            PortfolioAnalyticsService.instance = new PortfolioAnalyticsService();\n        }\n        return PortfolioAnalyticsService.instance;\n    }\n\n    /**\n     * Lấy portfolio summary\n     */\n    async getPortfolioSummary(address: string): Promise<PortfolioSummary> {\n        try {\n            console.log('Getting portfolio summary for address:', address);\n\n            // Get all assets\n            const [adaBalance, nfts, tokens, stakingPositions, liquidityPositions] = await Promise.all([\n                this.getADABalance(address),\n                this.nftService.getAddressNFTs(address),\n                this.getTokenBalances(address),\n                this.stakingService.getStakingPositions(address),\n                this.stakingService.getLiquidityPositions(address)\n            ]);\n\n            // Calculate values\n            const adaValue = adaBalance * this.getADAPrice();\n            const nftValue = this.calculateNFTValue(nfts);\n            const tokenValue = this.calculateTokenValue(tokens);\n            const lpValue = this.calculateLiquidityValue(liquidityPositions);\n            const stakingValue = this.calculateStakingValue(stakingPositions);\n            const rewardsValue = await this.calculateTotalRewards(address);\n\n            const totalValue = adaValue + nftValue + tokenValue + lpValue + stakingValue + rewardsValue;\n\n            // Calculate changes (simplified for now)\n            const totalChange24h = await this.calculatePortfolioChange(address, 1);\n            const totalChange7d = await this.calculatePortfolioChange(address, 7);\n            const totalChange30d = await this.calculatePortfolioChange(address, 30);\n\n            const summary: PortfolioSummary = {\n                totalValue,\n                totalChange24h,\n                totalChange7d,\n                totalChange30d,\n                adaValue,\n                nftValue,\n                tokenValue,\n                lpValue,\n                stakingValue,\n                rewardsValue,\n                lastUpdated: new Date()\n            };\n\n            // Cache summary\n            await this.cachePortfolioSummary(address, summary);\n\n            return summary;\n\n        } catch (error) {\n            console.error('Failed to get portfolio summary:', error);\n            throw new Error(`Failed to get portfolio summary: ${error}`);\n        }\n    }\n\n    /**\n     * Lấy portfolio assets\n     */\n    async getPortfolioAssets(address: string): Promise<PortfolioAsset[]> {\n        try {\n            const [adaBalance, nfts, tokens, stakingPositions, liquidityPositions] = await Promise.all([\n                this.getADABalance(address),\n                this.nftService.getAddressNFTs(address),\n                this.getTokenBalances(address),\n                this.stakingService.getStakingPositions(address),\n                this.stakingService.getLiquidityPositions(address)\n            ]);\n\n            const assets: PortfolioAsset[] = [];\n\n            // Add ADA\n            if (adaBalance > 0) {\n                const adaPrice = this.getADAPrice();\n                assets.push({\n                    id: 'ada',\n                    assetId: 'ada',\n                    name: 'Cardano',\n                    symbol: 'ADA',\n                    type: 'ada',\n                    quantity: adaBalance.toString(),\n                    price: adaPrice,\n                    value: adaBalance * adaPrice,\n                    change24h: this.getADAChange24h(),\n                    change7d: this.getADAChange7d(),\n                    change30d: this.getADAChange30d(),\n                    allocation: 0, // Will be calculated\n                    lastUpdated: new Date()\n                });\n            }\n\n            // Add NFTs\n            nfts.forEach(nft => {\n                const nftValue = this.estimateNFTValue(nft);\n                assets.push({\n                    id: nft.id,\n                    assetId: nft.assetId,\n                    name: nft.metadata?.name || 'Unknown NFT',\n                    symbol: 'NFT',\n                    type: 'nft',\n                    quantity: nft.quantity,\n                    price: nftValue,\n                    value: nftValue * parseFloat(nft.quantity),\n                    change24h: 0, // NFTs don't have daily changes like tokens\n                    change7d: 0,\n                    change30d: 0,\n                    allocation: 0,\n                    lastUpdated: new Date()\n                });\n            });\n\n            // Add tokens\n            tokens.forEach(token => {\n                const tokenPrice = this.getTokenPrice(token.symbol);\n                assets.push({\n                    id: token.id,\n                    assetId: token.assetId,\n                    name: token.name,\n                    symbol: token.symbol,\n                    type: 'token',\n                    quantity: token.quantity,\n                    price: tokenPrice,\n                    value: tokenPrice * parseFloat(token.quantity),\n                    change24h: this.getTokenChange24h(token.symbol),\n                    change7d: this.getTokenChange7d(token.symbol),\n                    change30d: this.getTokenChange30d(token.symbol),\n                    allocation: 0,\n                    lastUpdated: new Date()\n                });\n            });\n\n            // Add staking positions\n            stakingPositions.forEach(position => {\n                assets.push({\n                    id: position.id,\n                    assetId: `staking_${position.poolId}`,\n                    name: `Staking in ${position.poolName}`,\n                    symbol: 'ADA',\n                    type: 'ada',\n                    quantity: position.amount,\n                    price: this.getADAPrice(),\n                    value: parseFloat(position.amount) * this.getADAPrice(),\n                    change24h: this.getADAChange24h(),\n                    change7d: this.getADAChange7d(),\n                    change30d: this.getADAChange30d(),\n                    allocation: 0,\n                    lastUpdated: new Date()\n                });\n            });\n\n            // Add liquidity positions\n            liquidityPositions.forEach(position => {\n                const lpValue = this.calculateLiquidityPositionValue(position);\n                assets.push({\n                    id: position.id,\n                    assetId: `lp_${position.poolId}`,\n                    name: `LP ${position.poolName}`,\n                    symbol: 'LP',\n                    type: 'lp_token',\n                    quantity: position.liquidityTokens,\n                    price: lpValue / parseFloat(position.liquidityTokens || '1'),\n                    value: lpValue,\n                    change24h: 0, // LP tokens have complex pricing\n                    change7d: 0,\n                    change30d: 0,\n                    allocation: 0,\n                    lastUpdated: new Date()\n                });\n            });\n\n            // Calculate allocations\n            const totalValue = assets.reduce((sum, asset) => sum + asset.value, 0);\n            assets.forEach(asset => {\n                asset.allocation = totalValue > 0 ? (asset.value / totalValue) * 100 : 0;\n            });\n\n            return assets;\n\n        } catch (error) {\n            console.error('Failed to get portfolio assets:', error);\n            throw new Error(`Failed to get portfolio assets: ${error}`);\n        }\n    }\n\n    /**\n     * Lấy portfolio performance history\n     */\n    async getPortfolioPerformance(\n        address: string,\n        days: number = 30\n    ): Promise<PortfolioPerformance[]> {\n        try {\n            const performance: PortfolioPerformance[] = [];\n            const endDate = new Date();\n            const startDate = new Date(endDate.getTime() - days * 24 * 60 * 60 * 1000);\n\n            // Get historical data points\n            for (let i = 0; i <= days; i++) {\n                const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);\n                const value = await this.getHistoricalPortfolioValue(address, date);\n                const previousValue = i > 0 ? await this.getHistoricalPortfolioValue(address, new Date(date.getTime() - 24 * 60 * 60 * 1000)) : value;\n\n                const change = value - previousValue;\n                const changePercent = previousValue > 0 ? (change / previousValue) * 100 : 0;\n\n                performance.push({\n                    date,\n                    value,\n                    change,\n                    changePercent\n                });\n            }\n\n            return performance;\n\n        } catch (error) {\n            console.error('Failed to get portfolio performance:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Lấy transaction analytics\n     */\n    async getTransactionAnalytics(address: string): Promise<TransactionAnalytics> {\n        try {\n            // Get transaction history\n            const transactions = await this.cardanoAPI.getAddressTransactions(address);\n\n            // Calculate transaction metrics\n            const totalVolume = transactions.reduce((sum, tx) => {\n                const amount = (tx as any).amount || '0';\n                return sum + parseFloat(amount);\n            }, 0);\n\n            const feesPaid = transactions.reduce((sum, tx) => {\n                const fee = (tx as any).fee || '0';\n                return sum + parseFloat(fee);\n            }, 0);\n\n            const transactionCount = transactions.length;\n\n            // Calculate recipient distribution\n            const recipientMap = new Map<string, { count: number; volume: number }>();\n\n            transactions.forEach(tx => {\n                const to = (tx as any).to;\n                if (to && to !== address) {\n                    const current = recipientMap.get(to) || { count: 0, volume: 0 };\n                    current.count += 1;\n                    const amount = (tx as any).amount || '0';\n                    current.volume += parseFloat(amount);\n                    recipientMap.set(to, current);\n                }\n            });\n\n            // Calculate daily volume trends\n            const dailyVolume = new Map<string, number>();\n\n            transactions.forEach(tx => {\n                const timestamp = (tx as any).timestamp || tx.block_time;\n                if (timestamp) {\n                    const txDate = new Date(timestamp);\n                    const dateKey = txDate.toISOString().split('T')[0];\n\n                    const dayTransactions = transactions.filter(t => {\n                        const tTimestamp = (t as any).timestamp || t.block_time;\n                        if (tTimestamp) {\n                            const tDate = new Date(tTimestamp);\n                            return tDate.toISOString().split('T')[0] === dateKey;\n                        }\n                        return false;\n                    });\n\n                    const volume = dayTransactions.reduce((sum, t) => {\n                        const amount = (t as any).amount || '0';\n                        return sum + parseFloat(amount);\n                    }, 0);\n\n                    dailyVolume.set(dateKey, volume);\n                }\n            });\n\n            // Get rewards earned\n            const rewardsEarned = await this.calculateTotalRewards(address);\n\n            // Analyze recipients\n            const mostFrequentRecipients = Array.from(recipientMap.entries())\n                .map(([address, data]) => ({ address, ...data }))\n                .sort((a, b) => b.count - a.count)\n                .slice(0, 10);\n\n            // Calculate transaction trends (last 30 days)\n            const trends: Array<{ date: Date; count: number; volume: number }> = [];\n            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n\n            for (let i = 0; i < 30; i++) {\n                const date = new Date(thirtyDaysAgo.getTime() + i * 24 * 60 * 60 * 1000);\n                const dateKey = date.toISOString().split('T')[0];\n                const count = dailyVolume.get(dateKey) || 0;\n                const volume = dailyVolume.get(dateKey) || 0;\n\n                trends.push({ date, count, volume });\n            }\n\n            return {\n                totalTransactions: transactionCount,\n                totalVolume,\n                averageTransactionSize: transactionCount > 0 ? totalVolume / transactionCount : 0,\n                mostFrequentRecipients,\n                transactionTrends: trends,\n                feesPaid,\n                rewardsEarned\n            };\n\n        } catch (error) {\n            console.error('Failed to get transaction analytics:', error);\n            throw new Error(`Failed to get transaction analytics: ${error}`);\n        }\n    }\n\n    /**\n     * Lấy staking analytics\n     */\n    async getStakingAnalytics(address: string): Promise<StakingAnalytics> {\n        try {\n            const stakingPositions = await this.stakingService.getStakingPositions(address);\n\n            const totalStaked = stakingPositions.reduce((sum, pos) => sum + parseFloat(pos.amount), 0);\n            const totalRewards = stakingPositions.reduce((sum, pos) => sum + parseFloat(pos.rewards), 0);\n\n            // Calculate average APY\n            const totalAPY = stakingPositions.reduce((sum, pos) => sum + 5.5, 0); // Simplified\n            const averageAPY = stakingPositions.length > 0 ? totalAPY / stakingPositions.length : 0;\n\n            // Get top pools\n            const topPools = stakingPositions\n                .map(pos => ({\n                    poolId: pos.poolId,\n                    name: pos.poolName,\n                    amount: parseFloat(pos.amount),\n                    rewards: parseFloat(pos.rewards),\n                    apy: 5.5 // Simplified\n                }))\n                .sort((a, b) => b.amount - a.amount)\n                .slice(0, 5);\n\n            // Generate staking history (simplified)\n            const stakingHistory: Array<{ date: Date; staked: number; rewards: number }> = [];\n            const startDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000); // 90 days\n\n            for (let i = 0; i < 90; i += 7) { // Weekly data points\n                const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);\n                const staked = totalStaked * (0.5 + (i / 90) * 0.5); // Simulate growth\n                const rewards = totalRewards * (i / 90); // Simulate reward accumulation\n\n                stakingHistory.push({ date, staked, rewards });\n            }\n\n            return {\n                totalStaked,\n                totalRewards,\n                averageAPY,\n                topPools,\n                stakingHistory\n            };\n\n        } catch (error) {\n            console.error('Failed to get staking analytics:', error);\n            throw new Error(`Failed to get staking analytics: ${error}`);\n        }\n    }\n\n    /**\n     * Lấy NFT collection analytics\n     */\n    async getNFTCollectionAnalytics(address: string): Promise<NFTCollectionAnalytics> {\n        try {\n            const nfts = await this.nftService.getAddressNFTs(address);\n\n            const totalNFTs = nfts.length;\n            const totalValue = this.calculateNFTValue(nfts);\n            const averageValue = totalNFTs > 0 ? totalValue / totalNFTs : 0;\n\n            // Group by policy ID\n            const collectionMap = new Map<string, { count: number; value: number }>();\n            nfts.forEach(nft => {\n                const current = collectionMap.get(nft.policyId) || { count: 0, value: 0 };\n                current.count++;\n                current.value += this.estimateNFTValue(nft);\n                collectionMap.set(nft.policyId, current);\n            });\n\n            const topCollections = Array.from(collectionMap.entries())\n                .map(([policyId, data]) => ({ policyId, name: `Collection ${policyId.slice(0, 8)}`, ...data }))\n                .sort((a, b) => b.value - a.value)\n                .slice(0, 10);\n\n            // Get recent mints\n            const recentMints = nfts\n                .filter(nft => nft.createdAt > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))\n                .map(nft => ({\n                    assetId: nft.assetId,\n                    name: nft.metadata?.name || 'Unknown NFT',\n                    value: this.estimateNFTValue(nft),\n                    date: nft.createdAt\n                }))\n                .sort((a, b) => b.date.getTime() - a.date.getTime())\n                .slice(0, 10);\n\n            // Mock floor prices\n            const floorPrices = Array.from(collectionMap.keys()).map(policyId => ({\n                policyId,\n                floorPrice: Math.random() * 100 + 10, // Mock data\n                lastUpdated: new Date()\n            }));\n\n            return {\n                totalNFTs,\n                totalValue,\n                averageValue,\n                topCollections,\n                recentMints,\n                floorPrices\n            };\n\n        } catch (error) {\n            console.error('Failed to get NFT collection analytics:', error);\n            throw new Error(`Failed to get NFT collection analytics: ${error}`);\n        }\n    }\n\n    /**\n     * Lấy risk metrics\n     */\n    async getRiskMetrics(address: string): Promise<RiskMetrics> {\n        try {\n            // Get portfolio performance\n            const performance = await this.getPortfolioPerformance(address, 90);\n\n            if (performance.length < 2) {\n                return {\n                    volatility: 0,\n                    sharpeRatio: 0,\n                    maxDrawdown: 0,\n                    beta: 1,\n                    correlation: 0\n                };\n            }\n\n            // Calculate volatility\n            const returns = performance.slice(1).map((p, i) => {\n                const prev = performance[i];\n                return prev.value > 0 ? (p.value - prev.value) / prev.value : 0;\n            });\n\n            const meanReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;\n            const variance = returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / returns.length;\n            const volatility = Math.sqrt(variance);\n\n            // Calculate Sharpe ratio (simplified)\n            const riskFreeRate = 0.02; // 2% annual\n            const sharpeRatio = (meanReturn - riskFreeRate / 365) / volatility;\n\n            // Calculate max drawdown\n            let maxDrawdown = 0;\n            let peak = performance[0].value;\n\n            performance.forEach(p => {\n                if (p.value > peak) {\n                    peak = p.value;\n                }\n                const drawdown = (peak - p.value) / peak;\n                if (drawdown > maxDrawdown) {\n                    maxDrawdown = drawdown;\n                }\n            });\n\n            // Calculate beta (simplified - assuming 1 for now)\n            const beta = 1;\n\n            // Calculate correlation with ADA (simplified)\n            const correlation = 0.8; // High correlation with ADA\n\n            return {\n                volatility,\n                sharpeRatio,\n                maxDrawdown,\n                beta,\n                correlation\n            };\n\n        } catch (error) {\n            console.error('Failed to get risk metrics:', error);\n            return {\n                volatility: 0,\n                sharpeRatio: 0,\n                maxDrawdown: 0,\n                beta: 1,\n                correlation: 0\n            };\n        }\n    }\n\n    // Private helper methods\n    private async getADABalance(address: string): Promise<number> {\n        try {\n            const balance = await this.cardanoAPI.getAddressBalance(address);\n            return parseFloat(balance) / 1000000; // Convert from lovelace to ADA\n        } catch (error) {\n            console.error('Failed to get ADA balance:', error);\n            return 0;\n        }\n    }\n\n    private async getTokenBalances(address: string): Promise<Array<{ id: string; assetId: string; name: string; symbol: string; quantity: string }>> {\n        try {\n            const assets = await this.cardanoAPI.getAddressAssets(address);\n            return assets\n                .filter(asset => asset.quantity !== '1' && asset.asset_name) // Filter out NFTs\n                .map(asset => ({\n                    id: asset.asset,\n                    assetId: asset.asset,\n                    name: asset.asset_name || 'Unknown Token',\n                    symbol: asset.asset_name || 'UNKNOWN',\n                    quantity: asset.quantity\n                }));\n        } catch (error) {\n            console.error('Failed to get token balances:', error);\n            return [];\n        }\n    }\n\n    private getADAPrice(): number {\n        // This would integrate with price APIs\n        // For now, return mock price\n        return 0.65;\n    }\n\n    private getADAChange24h(): number {\n        return 2.5; // Mock 2.5% change\n    }\n\n    private getADAChange7d(): number {\n        return -1.2; // Mock -1.2% change\n    }\n\n    private getADAChange30d(): number {\n        return 8.7; // Mock 8.7% change\n    }\n\n    private getTokenPrice(symbol: string): number {\n        // This would integrate with price APIs\n        // For now, return mock prices\n        const prices: { [key: string]: number } = {\n            'AGIX': 0.25,\n            'MIN': 0.15,\n            'SUNDAE': 0.08\n        };\n        return prices[symbol] || 0.01;\n    }\n\n    private getTokenChange24h(symbol: string): number {\n        // Mock changes\n        return Math.random() * 10 - 5; // -5% to +5%\n    }\n\n    private getTokenChange7d(symbol: string): number {\n        return Math.random() * 20 - 10; // -10% to +10%\n    }\n\n    private getTokenChange30d(symbol: string): number {\n        return Math.random() * 40 - 20; // -20% to +20%\n    }\n\n    private calculateNFTValue(nfts: any[]): number {\n        return nfts.reduce((sum, nft) => sum + this.estimateNFTValue(nft), 0);\n    }\n\n    private estimateNFTValue(nft: any): number {\n        // This would integrate with NFT pricing APIs\n        // For now, return mock values\n        return Math.random() * 100 + 10; // $10-$110\n    }\n\n    private calculateTokenValue(tokens: any[]): number {\n        return tokens.reduce((sum, token) => {\n            const price = this.getTokenPrice(token.symbol);\n            return sum + (price * parseFloat(token.quantity));\n        }, 0);\n    }\n\n    private calculateLiquidityValue(positions: any[]): number {\n        return positions.reduce((sum, pos) => sum + this.calculateLiquidityPositionValue(pos), 0);\n    }\n\n    private calculateLiquidityPositionValue(position: any): number {\n        // Simplified calculation\n        return parseFloat(position.tokenAAmount || '0') * this.getADAPrice() * 2;\n    }\n\n    private calculateStakingValue(positions: any[]): number {\n        return positions.reduce((sum, pos) => sum + parseFloat(pos.amount), 0) * this.getADAPrice();\n    }\n\n    private async calculateTotalRewards(address: string): Promise<number> {\n        try {\n            const stakingPositions = await this.stakingService.getStakingPositions(address);\n            return stakingPositions.reduce((sum, pos) => sum + parseFloat(pos.rewards || '0'), 0);\n        } catch (error) {\n            return 0;\n        }\n    }\n\n    private async calculatePortfolioChange(address: string, days: number): Promise<number> {\n        try {\n            const currentValue = await this.getPortfolioSummary(address);\n            const pastDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n            const pastValue = await this.getHistoricalPortfolioValue(address, pastDate);\n\n            return pastValue > 0 ? ((currentValue.totalValue - pastValue) / pastValue) * 100 : 0;\n        } catch (error) {\n            return 0;\n        }\n    }\n\n    private async getHistoricalPortfolioValue(address: string, date: Date): Promise<number> {\n        // This would integrate with historical data APIs\n        // For now, return mock data\n        const baseValue = 10000; // Base portfolio value\n        const timeFactor = (Date.now() - date.getTime()) / (30 * 24 * 60 * 60 * 1000); // Days ago\n        return baseValue * (1 + timeFactor * 0.01); // 1% growth per day\n    }\n\n    private async cachePortfolioSummary(address: string, summary: PortfolioSummary): Promise<void> {\n        try {\n            await AsyncStorage.setItem(`portfolio_summary_${address}`, JSON.stringify(summary));\n        } catch (error) {\n            console.error('Failed to cache portfolio summary:', error);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}