{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { CardanoWalletService } from \"./CardanoWalletService\";\nimport { NetworkService } from \"./NetworkService\";\nimport { ErrorHandler, ErrorType, ErrorSeverity } from \"./ErrorHandler\";\nimport { performanceMonitor } from \"./PerformanceMonitor\";\nimport { ConfigurationService } from \"./ConfigurationService\";\nimport { CardanoAPIService } from \"./CardanoAPIService\";\nexport var WalletDataService = function () {\n  function WalletDataService() {\n    _classCallCheck(this, WalletDataService);\n    this.cache = new Map();\n    this.CACHE_TTL = 30000;\n    this.walletService = CardanoWalletService.getInstance();\n    this.cardanoAPIService = CardanoAPIService.getInstance();\n    this.networkService = NetworkService.getInstance();\n    this.errorHandler = ErrorHandler.getInstance();\n    this.configService = ConfigurationService.getInstance();\n  }\n  return _createClass(WalletDataService, [{\n    key: \"getRealBalance\",\n    value: (function () {\n      var _getRealBalance = _asyncToGenerator(function* (address) {\n        var _this = this;\n        return performanceMonitor.measureAsync('getRealBalance', _asyncToGenerator(function* () {\n          try {\n            if (!_this.networkService.isOnline()) {\n              throw new Error('No network connection');\n            }\n            var balance = yield _this.walletService.getBalance(address);\n            _this.cache.set(`balance_${address}`, {\n              data: balance,\n              timestamp: Date.now(),\n              ttl: _this.CACHE_TTL\n            });\n            return balance;\n          } catch (error) {\n            _this.errorHandler.handleError(error, 'WalletDataService.getRealBalance', ErrorSeverity.MEDIUM, ErrorType.NETWORK);\n            var cached = _this.getCachedData(`balance_${address}`);\n            if (cached) {\n              return cached;\n            }\n            throw error;\n          }\n        }));\n      });\n      function getRealBalance(_x) {\n        return _getRealBalance.apply(this, arguments);\n      }\n      return getRealBalance;\n    }())\n  }, {\n    key: \"getRealTransactionHistory\",\n    value: (function () {\n      var _getRealTransactionHistory = _asyncToGenerator(function* (address) {\n        var _this2 = this;\n        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n        return performanceMonitor.measureAsync('getRealTransactionHistory', _asyncToGenerator(function* () {\n          try {\n            if (!_this2.networkService.isOnline()) {\n              throw new Error('No network connection');\n            }\n            var walletService = CardanoWalletService.getInstance();\n            var transactions = yield _this2.cardanoAPIService.getAddressTransactions(address, limit);\n            var transactionData = transactions.map(function (tx) {\n              return {\n                id: tx.hash || `tx_${Date.now()}`,\n                hash: tx.hash || '',\n                type: _this2.determineTransactionType(tx, address),\n                amount: tx.amount || '0',\n                fee: tx.fee || '0',\n                from: tx.from || 'unknown',\n                to: tx.to || 'unknown',\n                status: _this2.mapTransactionStatus(tx.status || 'confirmed'),\n                timestamp: new Date(tx.block_time * 1000 || Date.now()),\n                blockHeight: 0,\n                confirmations: 0\n              };\n            });\n            for (var tx of transactionData) {\n              try {\n                var blockHeight = yield _this2.extractBlockHeight(tx);\n                if (blockHeight !== undefined) {\n                  tx.blockHeight = blockHeight;\n                  tx.confirmations = yield _this2.calculateConfirmations(tx);\n                }\n              } catch (error) {\n                console.warn('Failed to get block height for transaction:', tx.hash, error);\n              }\n            }\n            _this2.cache.set(`transactions_${address}_${limit}`, {\n              data: transactionData,\n              timestamp: Date.now(),\n              ttl: _this2.CACHE_TTL\n            });\n            return transactionData;\n          } catch (error) {\n            _this2.errorHandler.handleError(error, 'WalletDataService.getRealTransactionHistory', ErrorSeverity.MEDIUM, ErrorType.NETWORK);\n            return [];\n          }\n        }));\n      });\n      function getRealTransactionHistory(_x2) {\n        return _getRealTransactionHistory.apply(this, arguments);\n      }\n      return getRealTransactionHistory;\n    }())\n  }, {\n    key: \"refreshWalletData\",\n    value: (function () {\n      var _refreshWalletData = _asyncToGenerator(function* (address) {\n        var _this3 = this;\n        return performanceMonitor.measureAsync('refreshWalletData', _asyncToGenerator(function* () {\n          try {\n            var _yield$Promise$all = yield Promise.all([_this3.getRealBalance(address), _this3.getRealTransactionHistory(address, 50)]),\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2),\n              balance = _yield$Promise$all2[0],\n              transactions = _yield$Promise$all2[1];\n            var result = {\n              balance: balance,\n              transactions: transactions,\n              lastUpdated: new Date()\n            };\n            _this3.cache.set(`wallet_data_${address}`, {\n              data: result,\n              timestamp: Date.now(),\n              ttl: _this3.CACHE_TTL\n            });\n            return result;\n          } catch (error) {\n            _this3.errorHandler.handleError(error, 'WalletDataService.refreshWalletData', ErrorSeverity.HIGH, ErrorType.WALLET);\n            throw error;\n          }\n        }));\n      });\n      function refreshWalletData(_x3) {\n        return _refreshWalletData.apply(this, arguments);\n      }\n      return refreshWalletData;\n    }())\n  }, {\n    key: \"determineTransactionType\",\n    value: function determineTransactionType(tx, currentAddress) {\n      if (tx.isOffline) return 'offline';\n      if (tx.to === currentAddress) return 'received';\n      if (tx.from === currentAddress) return 'sent';\n      return 'received';\n    }\n  }, {\n    key: \"mapTransactionStatus\",\n    value: function mapTransactionStatus(status) {\n      switch (status) {\n        case 'confirmed':\n          return 'confirmed';\n        case 'pending':\n          return 'pending';\n        case 'failed':\n          return 'failed';\n        case 'offline_signed':\n        case 'queued':\n          return 'queued';\n        default:\n          return 'pending';\n      }\n    }\n  }, {\n    key: \"extractBlockHeight\",\n    value: (function () {\n      var _extractBlockHeight = _asyncToGenerator(function* (tx) {\n        try {\n          if (tx.metadata && tx.metadata.blockHeight) {\n            return parseInt(tx.metadata.blockHeight, 10);\n          }\n          if (tx.blockHash) {\n            try {\n              var blockHeight = yield this.getBlockHeightFromHash(tx.blockHash, tx.network);\n              if (blockHeight !== undefined) {\n                return blockHeight;\n              }\n            } catch (error) {\n              console.warn('Failed to get block height from hash:', error);\n            }\n            return undefined;\n          }\n          if (tx.timestamp && tx.network) {\n            var genesisTime = tx.network === 'mainnet' ? 1506203091000 : 1596059091000;\n            var blockTime = 20000;\n            var estimatedHeight = Math.floor((tx.timestamp.getTime() - genesisTime) / blockTime);\n            return Math.max(0, estimatedHeight);\n          }\n          return undefined;\n        } catch (error) {\n          console.warn('Failed to extract block height:', error);\n          return undefined;\n        }\n      });\n      function extractBlockHeight(_x4) {\n        return _extractBlockHeight.apply(this, arguments);\n      }\n      return extractBlockHeight;\n    }())\n  }, {\n    key: \"calculateConfirmations\",\n    value: (function () {\n      var _calculateConfirmations = _asyncToGenerator(function* (tx) {\n        try {\n          var txBlockHeight = yield this.extractBlockHeight(tx);\n          if (txBlockHeight === undefined) return undefined;\n          var currentBlockHeight = yield this.getCurrentBlockHeight(tx.network);\n          if (currentBlockHeight === undefined) return undefined;\n          var confirmations = Math.max(0, currentBlockHeight - txBlockHeight);\n          if (confirmations >= 2160) {\n            return confirmations;\n          }\n          return confirmations;\n        } catch (error) {\n          console.warn('Failed to calculate confirmations:', error);\n          return undefined;\n        }\n      });\n      function calculateConfirmations(_x5) {\n        return _calculateConfirmations.apply(this, arguments);\n      }\n      return calculateConfirmations;\n    }())\n  }, {\n    key: \"getCurrentBlockHeight\",\n    value: (function () {\n      var _getCurrentBlockHeight = _asyncToGenerator(function* (network) {\n        try {\n          var cacheKey = `block_height_${network}`;\n          var cached = this.getCachedData(cacheKey);\n          if (cached) {\n            return cached;\n          }\n          var blockHeight = yield this.fetchRealTimeBlockHeight(network);\n          if (blockHeight !== undefined) {\n            this.cache.set(cacheKey, {\n              data: blockHeight,\n              timestamp: Date.now(),\n              ttl: 30000\n            });\n            return blockHeight;\n          }\n          var estimatedHeight = this.estimateBlockHeight(network);\n          this.cache.set(cacheKey, {\n            data: estimatedHeight,\n            timestamp: Date.now(),\n            ttl: 60000\n          });\n          return estimatedHeight;\n        } catch (error) {\n          console.warn('Failed to get current block height:', error);\n          return this.estimateBlockHeight(network);\n        }\n      });\n      function getCurrentBlockHeight(_x6) {\n        return _getCurrentBlockHeight.apply(this, arguments);\n      }\n      return getCurrentBlockHeight;\n    }())\n  }, {\n    key: \"fetchRealTimeBlockHeight\",\n    value: (function () {\n      var _fetchRealTimeBlockHeight = _asyncToGenerator(function* (network) {\n        try {\n          var apiEndpoints = this.getBlockHeightAPIEndpoints(network);\n          for (var endpoint of apiEndpoints) {\n            try {\n              var response = yield fetch(endpoint.url, {\n                method: 'GET',\n                headers: endpoint.headers\n              });\n              if (response.ok) {\n                var data = yield response.json();\n                var blockHeight = this.extractBlockHeightFromResponse(data, endpoint.format);\n                if (blockHeight !== undefined) {\n                  console.log(`Block height fetched from ${endpoint.name}:`, blockHeight);\n                  return blockHeight;\n                }\n              }\n            } catch (error) {\n              console.warn(`Failed to fetch from ${endpoint.name}:`, error);\n              continue;\n            }\n          }\n          return undefined;\n        } catch (error) {\n          console.error('All block height APIs failed:', error);\n          return undefined;\n        }\n      });\n      function fetchRealTimeBlockHeight(_x7) {\n        return _fetchRealTimeBlockHeight.apply(this, arguments);\n      }\n      return fetchRealTimeBlockHeight;\n    }())\n  }, {\n    key: \"getBlockHeightFromHash\",\n    value: (function () {\n      var _getBlockHeightFromHash = _asyncToGenerator(function* (blockHash, network) {\n        try {\n          var endpoints = this.getBlockHeightAPIEndpoints(network);\n          for (var endpoint of endpoints) {\n            try {\n              var response = yield fetch(endpoint.url, {\n                method: 'GET',\n                headers: endpoint.headers,\n                signal: AbortSignal.timeout(5000)\n              });\n              if (response.ok) {\n                var data = yield response.json();\n                return this.extractBlockHeightFromResponse(data, endpoint.format);\n              }\n            } catch (error) {\n              console.warn(`Failed to fetch from ${endpoint.url}:`, error);\n              continue;\n            }\n          }\n          return yield this.estimateBlockHeight(network);\n        } catch (error) {\n          console.error('Failed to get block height from hash:', error);\n          return undefined;\n        }\n      });\n      function getBlockHeightFromHash(_x8, _x9) {\n        return _getBlockHeightFromHash.apply(this, arguments);\n      }\n      return getBlockHeightFromHash;\n    }())\n  }, {\n    key: \"getNetworkType\",\n    value: function getNetworkType(network) {\n      if (network.toLowerCase().includes('mainnet')) {\n        return 'mainnet';\n      }\n      return 'testnet';\n    }\n  }, {\n    key: \"getBlockHeightAPIEndpoints\",\n    value: function getBlockHeightAPIEndpoints(network) {\n      var baseUrl = network === 'mainnet' ? 'https://api.blockfrost.io/v0' : 'https://api.blockfrost.io/v0/testnet';\n      return [{\n        name: 'Blockfrost',\n        url: `${baseUrl}/blocks/latest`,\n        format: 'blockfrost',\n        headers: {\n          'project_id': this.configService.getApiKey('blockfrost', this.getNetworkType(network)) || 'YOUR_BLOCKFROST_PROJECT_ID'\n        }\n      }, {\n        name: 'CardanoScan',\n        url: `https://${network === 'mainnet' ? 'api' : 'testnet-api'}.cardanoscan.io/api/blocks/latest`,\n        format: 'cardanoscan'\n      }, {\n        name: 'AdaStat',\n        url: `https://adastat.net/api/v1/blocks/latest?network=${network}`,\n        format: 'adastat'\n      }];\n    }\n  }, {\n    key: \"extractBlockHeightFromResponse\",\n    value: function extractBlockHeightFromResponse(data, format) {\n      try {\n        switch (format) {\n          case 'blockfrost':\n            return data.height || data.block_height;\n          case 'cardanoscan':\n            return data.blockHeight || data.height;\n          case 'adastat':\n            return data.block_height || data.height;\n          default:\n            return data.height || data.blockHeight || data.block_height || data.number;\n        }\n      } catch (error) {\n        console.warn('Failed to extract block height from response:', error);\n        return undefined;\n      }\n    }\n  }, {\n    key: \"estimateBlockHeight\",\n    value: function estimateBlockHeight(network) {\n      var genesisTime = network === 'mainnet' ? 1506203091000 : 1596059091000;\n      var blockTime = 20000;\n      var estimatedHeight = Math.floor((Date.now() - genesisTime) / blockTime);\n      return Math.max(0, estimatedHeight);\n    }\n  }, {\n    key: \"getCachedData\",\n    value: function getCachedData(key) {\n      var cached = this.cache.get(key);\n      if (!cached) return null;\n      var now = Date.now();\n      if (now - cached.timestamp > cached.ttl) {\n        this.cache.delete(key);\n        return null;\n      }\n      return cached.data;\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.cache.clear();\n    }\n  }, {\n    key: \"cleanupCache\",\n    value: function cleanupCache() {\n      var now = Date.now();\n      for (var _ref4 of this.cache.entries()) {\n        var _ref5 = _slicedToArray(_ref4, 2);\n        var key = _ref5[0];\n        var value = _ref5[1];\n        if (now - value.timestamp > value.ttl) {\n          this.cache.delete(key);\n        }\n      }\n    }\n  }, {\n    key: \"getCacheStats\",\n    value: function getCacheStats() {\n      return {\n        size: this.cache.size,\n        keys: Array.from(this.cache.keys())\n      };\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!WalletDataService.instance) {\n        WalletDataService.instance = new WalletDataService();\n      }\n      return WalletDataService.instance;\n    }\n  }]);\n}();","map":{"version":3,"names":["CardanoWalletService","NetworkService","ErrorHandler","ErrorType","ErrorSeverity","performanceMonitor","ConfigurationService","CardanoAPIService","WalletDataService","_classCallCheck","cache","Map","CACHE_TTL","walletService","getInstance","cardanoAPIService","networkService","errorHandler","configService","_createClass","key","value","_getRealBalance","_asyncToGenerator","address","_this","measureAsync","isOnline","Error","balance","getBalance","set","data","timestamp","Date","now","ttl","error","handleError","MEDIUM","NETWORK","cached","getCachedData","getRealBalance","_x","apply","arguments","_getRealTransactionHistory","_this2","limit","length","undefined","transactions","getAddressTransactions","transactionData","map","tx","id","hash","type","determineTransactionType","amount","fee","from","to","status","mapTransactionStatus","block_time","blockHeight","confirmations","extractBlockHeight","calculateConfirmations","console","warn","getRealTransactionHistory","_x2","_refreshWalletData","_this3","_yield$Promise$all","Promise","all","_yield$Promise$all2","_slicedToArray","result","lastUpdated","HIGH","WALLET","refreshWalletData","_x3","currentAddress","isOffline","_extractBlockHeight","metadata","parseInt","blockHash","getBlockHeightFromHash","network","genesisTime","blockTime","estimatedHeight","Math","floor","getTime","max","_x4","_calculateConfirmations","txBlockHeight","currentBlockHeight","getCurrentBlockHeight","_x5","_getCurrentBlockHeight","cacheKey","fetchRealTimeBlockHeight","estimateBlockHeight","_x6","_fetchRealTimeBlockHeight","apiEndpoints","getBlockHeightAPIEndpoints","endpoint","response","fetch","url","method","headers","ok","json","extractBlockHeightFromResponse","format","log","name","_x7","_getBlockHeightFromHash","endpoints","signal","AbortSignal","timeout","_x8","_x9","getNetworkType","toLowerCase","includes","baseUrl","getApiKey","height","block_height","number","get","delete","clearCache","clear","cleanupCache","_ref4","entries","_ref5","getCacheStats","size","keys","Array","instance"],"sources":["/Users/sonson/Documents/code/venera/X150-Valkyrie/src/services/WalletDataService.ts"],"sourcesContent":["import { CardanoWalletService } from './CardanoWalletService';\nimport { NetworkService } from './NetworkService';\nimport { ErrorHandler, ErrorType, ErrorSeverity } from './ErrorHandler';\nimport { performanceMonitor } from './PerformanceMonitor';\nimport { ConfigurationService } from './ConfigurationService';\nimport { CardanoAPIService } from './CardanoAPIService';\n\nexport interface WalletData {\n    balance: string;\n    address: string;\n    stakeAddress?: string;\n    network: 'mainnet' | 'testnet';\n    lastUpdated: Date;\n}\n\nexport interface TransactionData {\n    id: string;\n    hash: string;\n    type: 'received' | 'sent' | 'offline';\n    amount: string;\n    fee: string;\n    from: string;\n    to: string;\n    status: 'pending' | 'confirmed' | 'failed' | 'queued';\n    timestamp: Date;\n    blockHeight?: number;\n    confirmations?: number;\n}\n\nexport class WalletDataService {\n    private static instance: WalletDataService;\n    private walletService: CardanoWalletService;\n    private cardanoAPIService: CardanoAPIService;\n    private networkService: NetworkService;\n    private errorHandler: ErrorHandler;\n    private configService: ConfigurationService;\n    private cache: Map<string, { data: any; timestamp: number; ttl: number }> = new Map();\n    private readonly CACHE_TTL = 30000; // 30 seconds\n\n    static getInstance(): WalletDataService {\n        if (!WalletDataService.instance) {\n            WalletDataService.instance = new WalletDataService();\n        }\n        return WalletDataService.instance;\n    }\n\n    constructor() {\n        this.walletService = CardanoWalletService.getInstance();\n        this.cardanoAPIService = CardanoAPIService.getInstance();\n        this.networkService = NetworkService.getInstance();\n        this.errorHandler = ErrorHandler.getInstance();\n        this.configService = ConfigurationService.getInstance();\n    }\n\n    /**\n     * Lấy balance thực tế của ví\n     */\n    async getRealBalance(address: string): Promise<string> {\n        return performanceMonitor.measureAsync('getRealBalance', async () => {\n            try {\n                // Check network connectivity\n                if (!this.networkService.isOnline()) {\n                    throw new Error('No network connection');\n                }\n\n                // Get balance from Cardano network\n                const balance = await this.walletService.getBalance(address);\n\n                // Cache the result\n                this.cache.set(`balance_${address}`, {\n                    data: balance,\n                    timestamp: Date.now(),\n                    ttl: this.CACHE_TTL\n                });\n\n                return balance;\n            } catch (error) {\n                this.errorHandler.handleError(\n                    error as Error,\n                    'WalletDataService.getRealBalance',\n                    ErrorSeverity.MEDIUM,\n                    ErrorType.NETWORK\n                );\n\n                // Return cached balance if available\n                const cached = this.getCachedData(`balance_${address}`);\n                if (cached) {\n                    return cached;\n                }\n\n                throw error;\n            }\n        });\n    }\n\n    /**\n     * Lấy transaction history thực tế\n     */\n    async getRealTransactionHistory(address: string, limit: number = 50): Promise<TransactionData[]> {\n        return performanceMonitor.measureAsync('getRealTransactionHistory', async () => {\n            try {\n                // Check network connectivity\n                if (!this.networkService.isOnline()) {\n                    throw new Error('No network connection');\n                }\n\n                // Get wallet service\n                const walletService = CardanoWalletService.getInstance();\n\n                // Get transaction history from API instead\n                const transactions = await this.cardanoAPIService.getAddressTransactions(address, limit);\n\n                // Transform to TransactionData format\n                const transactionData: TransactionData[] = transactions.map((tx: any) => ({\n                    id: tx.hash || `tx_${Date.now()}`,\n                    hash: tx.hash || '',\n                    type: this.determineTransactionType(tx, address),\n                    amount: (tx as any).amount || '0',\n                    fee: (tx as any).fee || '0',\n                    from: (tx as any).from || 'unknown',\n                    to: (tx as any).to || 'unknown',\n                    status: this.mapTransactionStatus((tx as any).status || 'confirmed'),\n                    timestamp: new Date((tx as any).block_time * 1000 || Date.now()),\n                    blockHeight: 0, // Will be updated below\n                    confirmations: 0 // Will be updated below\n                }));\n\n                // Update block height and confirmations\n                for (const tx of transactionData) {\n                    try {\n                        const blockHeight = await this.extractBlockHeight(tx);\n                        if (blockHeight !== undefined) {\n                            tx.blockHeight = blockHeight;\n                            tx.confirmations = await this.calculateConfirmations(tx);\n                        }\n                    } catch (error) {\n                        console.warn('Failed to get block height for transaction:', tx.hash, error);\n                    }\n                }\n\n                // Cache the result\n                this.cache.set(`transactions_${address}_${limit}`, {\n                    data: transactionData,\n                    timestamp: Date.now(),\n                    ttl: this.CACHE_TTL\n                });\n\n                return transactionData;\n            } catch (error) {\n                this.errorHandler.handleError(\n                    error as Error,\n                    'WalletDataService.getRealTransactionHistory',\n                    ErrorSeverity.MEDIUM,\n                    ErrorType.NETWORK\n                );\n                return [];\n            }\n        });\n    }\n\n    /**\n     * Refresh tất cả dữ liệu ví\n     */\n    async refreshWalletData(address: string): Promise<{\n        balance: string;\n        transactions: TransactionData[];\n        lastUpdated: Date;\n    }> {\n        return performanceMonitor.measureAsync('refreshWalletData', async () => {\n            try {\n                const [balance, transactions] = await Promise.all([\n                    this.getRealBalance(address),\n                    this.getRealTransactionHistory(address, 50)\n                ]);\n\n                const result = {\n                    balance,\n                    transactions,\n                    lastUpdated: new Date()\n                };\n\n                // Cache the complete result\n                this.cache.set(`wallet_data_${address}`, {\n                    data: result,\n                    timestamp: Date.now(),\n                    ttl: this.CACHE_TTL\n                });\n\n                return result;\n            } catch (error) {\n                this.errorHandler.handleError(\n                    error as Error,\n                    'WalletDataService.refreshWalletData',\n                    ErrorSeverity.HIGH,\n                    ErrorType.WALLET\n                );\n                throw error;\n            }\n        });\n    }\n\n    /**\n     * Xác định loại transaction\n     */\n    private determineTransactionType(tx: any, currentAddress: string): 'received' | 'sent' | 'offline' {\n        if (tx.isOffline) return 'offline';\n        if (tx.to === currentAddress) return 'received';\n        if (tx.from === currentAddress) return 'sent';\n        return 'received'; // Default fallback\n    }\n\n    /**\n     * Map transaction status\n     */\n    private mapTransactionStatus(status: string): 'pending' | 'confirmed' | 'failed' | 'queued' {\n        switch (status) {\n            case 'confirmed': return 'confirmed';\n            case 'pending': return 'pending';\n            case 'failed': return 'failed';\n            case 'offline_signed':\n            case 'queued': return 'queued';\n            default: return 'pending';\n        }\n    }\n\n    /**\n * Extract block height từ transaction metadata\n */\n    private async extractBlockHeight(tx: any): Promise<number | undefined> {\n        try {\n            // Extract from transaction metadata\n            if (tx.metadata && tx.metadata.blockHeight) {\n                return parseInt(tx.metadata.blockHeight, 10);\n            }\n\n            // Extract from transaction hash if available\n            if (tx.blockHash) {\n                // Implement block hash to height conversion via API\n                try {\n                    const blockHeight = await this.getBlockHeightFromHash(tx.blockHash, tx.network);\n                    if (blockHeight !== undefined) {\n                        return blockHeight;\n                    }\n                } catch (error) {\n                    console.warn('Failed to get block height from hash:', error);\n                }\n                return undefined;\n            }\n\n            // Extract from transaction timestamp and network info\n            if (tx.timestamp && tx.network) {\n                // Estimate block height based on timestamp\n                // Cardano produces ~1 block every 20 seconds\n                const genesisTime = tx.network === 'mainnet' ? 1506203091000 : 1596059091000;\n                const blockTime = 20000; // 20 seconds in milliseconds\n                const estimatedHeight = Math.floor((tx.timestamp.getTime() - genesisTime) / blockTime);\n                return Math.max(0, estimatedHeight);\n            }\n\n            return undefined;\n        } catch (error) {\n            console.warn('Failed to extract block height:', error);\n            return undefined;\n        }\n    }\n\n    /**\n * Calculate confirmations based on current block height\n */\n    private async calculateConfirmations(tx: any): Promise<number | undefined> {\n        try {\n            const txBlockHeight = await this.extractBlockHeight(tx);\n            if (txBlockHeight === undefined) return undefined;\n\n            // Get current network block height\n            const currentBlockHeight = await this.getCurrentBlockHeight(tx.network);\n            if (currentBlockHeight === undefined) return undefined;\n\n            // Calculate confirmations\n            const confirmations = Math.max(0, currentBlockHeight - txBlockHeight);\n\n            // Consider confirmed after 2160 blocks (1 day for Cardano)\n            if (confirmations >= 2160) {\n                return confirmations;\n            }\n\n            return confirmations;\n        } catch (error) {\n            console.warn('Failed to calculate confirmations:', error);\n            return undefined;\n        }\n    }\n\n    /**\n     * Get current block height for network với real-time fetching\n     */\n    private async getCurrentBlockHeight(network: string): Promise<number | undefined> {\n        try {\n            // Check cache first\n            const cacheKey = `block_height_${network}`;\n            const cached = this.getCachedData(cacheKey);\n\n            if (cached) {\n                return cached;\n            }\n\n            // Try to fetch real-time block height from Cardano APIs\n            const blockHeight = await this.fetchRealTimeBlockHeight(network);\n\n            if (blockHeight !== undefined) {\n                // Cache the real value\n                this.cache.set(cacheKey, {\n                    data: blockHeight,\n                    timestamp: Date.now(),\n                    ttl: 30000 // 30 seconds cache for real-time data\n                });\n                return blockHeight;\n            }\n\n            // Fallback to estimation if API fails\n            const estimatedHeight = this.estimateBlockHeight(network);\n\n            // Cache the estimate\n            this.cache.set(cacheKey, {\n                data: estimatedHeight,\n                timestamp: Date.now(),\n                ttl: 60000 // 1 minute cache for estimated data\n            });\n\n            return estimatedHeight;\n        } catch (error) {\n            console.warn('Failed to get current block height:', error);\n            return this.estimateBlockHeight(network);\n        }\n    }\n\n    /**\n     * Fetch real-time block height từ Cardano APIs\n     */\n    private async fetchRealTimeBlockHeight(network: string): Promise<number | undefined> {\n        try {\n            const apiEndpoints = this.getBlockHeightAPIEndpoints(network);\n\n            for (const endpoint of apiEndpoints) {\n                try {\n                    const response = await fetch(endpoint.url, {\n                        method: 'GET',\n                        headers: endpoint.headers,\n                    });\n\n                    if (response.ok) {\n                        const data = await response.json();\n                        const blockHeight = this.extractBlockHeightFromResponse(data, endpoint.format);\n\n                        if (blockHeight !== undefined) {\n                            console.log(`Block height fetched from ${endpoint.name}:`, blockHeight);\n                            return blockHeight;\n                        }\n                    }\n                } catch (error) {\n                    console.warn(`Failed to fetch from ${endpoint.name}:`, error);\n                    continue;\n                }\n            }\n\n            return undefined;\n        } catch (error) {\n            console.error('All block height APIs failed:', error);\n            return undefined;\n        }\n    }\n\n    /**\n     * Lấy block height từ block hash\n     */\n    private async getBlockHeightFromHash(blockHash: string, network: string): Promise<number | undefined> {\n        try {\n            // Try to get block height from multiple APIs\n            const endpoints = this.getBlockHeightAPIEndpoints(network);\n\n            for (const endpoint of endpoints) {\n                try {\n                    const response = await fetch(endpoint.url, {\n                        method: 'GET',\n                        headers: endpoint.headers,\n                        signal: AbortSignal.timeout(5000)\n                    });\n\n                    if (response.ok) {\n                        const data = await response.json();\n                        return this.extractBlockHeightFromResponse(data, endpoint.format);\n                    }\n                } catch (error) {\n                    console.warn(`Failed to fetch from ${endpoint.url}:`, error);\n                    continue;\n                }\n            }\n\n            // Fallback to estimation\n            return await this.estimateBlockHeight(network);\n\n        } catch (error) {\n            console.error('Failed to get block height from hash:', error);\n            return undefined;\n        }\n    }\n\n    /**\n     * Lấy network type từ string\n     */\n    private getNetworkType(network: string): 'mainnet' | 'testnet' {\n        if (network.toLowerCase().includes('mainnet')) {\n            return 'mainnet';\n        }\n        return 'testnet';\n    }\n\n    /**\n     * Get block height API endpoints cho network\n     */\n    private getBlockHeightAPIEndpoints(network: string): Array<{\n        name: string;\n        url: string;\n        format: string;\n        headers?: Record<string, string>;\n    }> {\n        const baseUrl = network === 'mainnet'\n            ? 'https://api.blockfrost.io/v0'\n            : 'https://api.blockfrost.io/v0/testnet';\n\n        return [\n            {\n                name: 'Blockfrost',\n                url: `${baseUrl}/blocks/latest`,\n                format: 'blockfrost',\n                headers: {\n                    'project_id': this.configService.getApiKey('blockfrost', this.getNetworkType(network)) || 'YOUR_BLOCKFROST_PROJECT_ID'\n                }\n            },\n            {\n                name: 'CardanoScan',\n                url: `https://${network === 'mainnet' ? 'api' : 'testnet-api'}.cardanoscan.io/api/blocks/latest`,\n                format: 'cardanoscan'\n            },\n            {\n                name: 'AdaStat',\n                url: `https://adastat.net/api/v1/blocks/latest?network=${network}`,\n                format: 'adastat'\n            }\n        ];\n    }\n\n    /**\n     * Extract block height từ API response\n     */\n    private extractBlockHeightFromResponse(data: any, format: string): number | undefined {\n        try {\n            switch (format) {\n                case 'blockfrost':\n                    return data.height || data.block_height;\n                case 'cardanoscan':\n                    return data.blockHeight || data.height;\n                case 'adastat':\n                    return data.block_height || data.height;\n                default:\n                    // Try common field names\n                    return data.height || data.blockHeight || data.block_height || data.number;\n            }\n        } catch (error) {\n            console.warn('Failed to extract block height from response:', error);\n            return undefined;\n        }\n    }\n\n    /**\n     * Estimate block height based on time\n     */\n    private estimateBlockHeight(network: string): number {\n        const genesisTime = network === 'mainnet' ? 1506203091000 : 1596059091000;\n        const blockTime = 20000; // 20 seconds\n        const estimatedHeight = Math.floor((Date.now() - genesisTime) / blockTime);\n        return Math.max(0, estimatedHeight);\n    }\n\n    /**\n     * Lấy cached data\n     */\n    private getCachedData(key: string): any | null {\n        const cached = this.cache.get(key);\n        if (!cached) return null;\n\n        const now = Date.now();\n        if (now - cached.timestamp > cached.ttl) {\n            this.cache.delete(key);\n            return null;\n        }\n\n        return cached.data;\n    }\n\n    /**\n     * Clear cache\n     */\n    clearCache(): void {\n        this.cache.clear();\n    }\n\n    /**\n     * Clear expired cache entries\n     */\n    cleanupCache(): void {\n        const now = Date.now();\n        for (const [key, value] of this.cache.entries()) {\n            if (now - value.timestamp > value.ttl) {\n                this.cache.delete(key);\n            }\n        }\n    }\n\n    /**\n     * Get cache statistics\n     */\n    getCacheStats(): { size: number; keys: string[] } {\n        return {\n            size: this.cache.size,\n            keys: Array.from(this.cache.keys())\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}