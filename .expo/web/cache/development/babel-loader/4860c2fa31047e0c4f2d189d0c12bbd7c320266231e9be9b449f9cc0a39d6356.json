{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport * as bip39 from 'bip39';\nimport { Address, BaseAddress, StakeCredential, Bip32PrivateKey, TransactionBuilder, TransactionOutput, Value, BigNum, LinearFee, TransactionBuilderConfigBuilder, TransactionInput, TransactionHash } from '@emurgo/cardano-serialization-lib-browser';\nimport { CARDANO_NETWORKS } from \"../constants/index\";\nimport { CardanoAPIService } from \"./CardanoAPIService\";\nimport { NetworkService } from \"./NetworkService\";\nimport { ErrorHandler } from \"./ErrorHandler\";\nimport { TransactionStatus } from \"../types/wallet\";\nexport var CardanoWalletService = function () {\n  function CardanoWalletService() {\n    var networkType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'testnet';\n    _classCallCheck(this, CardanoWalletService);\n    this.network = networkType === 'mainnet' ? CARDANO_NETWORKS.MAINNET : CARDANO_NETWORKS.TESTNET;\n    this.apiService = CardanoAPIService.getInstance();\n    this.apiService.setNetwork(networkType);\n    this.networkService = NetworkService.getInstance();\n    this.errorHandler = ErrorHandler.getInstance();\n  }\n  return _createClass(CardanoWalletService, [{\n    key: \"initializeFromMnemonic\",\n    value: (function () {\n      var _initializeFromMnemonic = _asyncToGenerator(function* (mnemonic) {\n        try {\n          if (!bip39.validateMnemonic(mnemonic)) {\n            throw new Error('Invalid mnemonic phrase');\n          }\n          var seed = bip39.mnemonicToSeedSync(mnemonic);\n          this.rootKey = Bip32PrivateKey.from_bip39_entropy(Buffer.from(seed), Buffer.from(''));\n          return true;\n        } catch (error) {\n          console.error('Failed to initialize wallet:', error);\n          return false;\n        }\n      });\n      function initializeFromMnemonic(_x) {\n        return _initializeFromMnemonic.apply(this, arguments);\n      }\n      return initializeFromMnemonic;\n    }())\n  }, {\n    key: \"createAccount\",\n    value: (function () {\n      var _createAccount = _asyncToGenerator(function* () {\n        var accountIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Main Account';\n        if (!this.rootKey) {\n          throw new Error('Wallet not initialized');\n        }\n        try {\n          var accountKey = this.rootKey.derive(1852 + 0x80000000).derive(1815 + 0x80000000).derive(accountIndex + 0x80000000);\n          var spendingKey = accountKey.derive(0).derive(0);\n          var stakingKey = accountKey.derive(2).derive(0);\n          var paymentCredential = StakeCredential.from_keyhash(spendingKey.to_public().to_raw_key().hash());\n          var stakeCredential = StakeCredential.from_keyhash(stakingKey.to_public().to_raw_key().hash());\n          var baseAddress = BaseAddress.new(this.network.networkId, paymentCredential, stakeCredential);\n          var address = baseAddress.to_address().to_bech32();\n          var stakeAddress = stakingKey.to_public().to_raw_key().hash().to_bech32('stake');\n          var account = {\n            id: `account_${accountIndex}`,\n            name: name,\n            address: address,\n            stakeAddress: stakeAddress,\n            balance: '0',\n            isActive: accountIndex === 0,\n            createdAt: new Date()\n          };\n          return account;\n        } catch (error) {\n          throw new Error(`Failed to create account: ${error}`);\n        }\n      });\n      function createAccount() {\n        return _createAccount.apply(this, arguments);\n      }\n      return createAccount;\n    }())\n  }, {\n    key: \"getBalance\",\n    value: (function () {\n      var _getBalance = _asyncToGenerator(function* (address) {\n        try {\n          var addressInfo = yield this.apiService.getAddressInfo(address);\n          var adaAmount = addressInfo.amount.find(function (a) {\n            return a.unit === 'lovelace';\n          });\n          return adaAmount ? adaAmount.quantity : '0';\n        } catch (error) {\n          console.error('Failed to get balance:', error);\n          return '0';\n        }\n      });\n      function getBalance(_x2) {\n        return _getBalance.apply(this, arguments);\n      }\n      return getBalance;\n    }())\n  }, {\n    key: \"buildTransaction\",\n    value: (function () {\n      var _buildTransaction = _asyncToGenerator(function* (fromAddress, toAddress, amount, metadata) {\n        try {\n          if (!CardanoWalletService.validateAddress(fromAddress)) {\n            throw new Error('Invalid sender address');\n          }\n          if (!CardanoWalletService.validateAddress(toAddress)) {\n            throw new Error('Invalid recipient address');\n          }\n          var amountNum = BigInt(amount);\n          if (amountNum <= 0) {\n            throw new Error('Amount must be greater than 0');\n          }\n          var utxos = yield this.getUTXOs(fromAddress);\n          if (utxos.length === 0) {\n            throw new Error('No UTXOs found for sender address');\n          }\n          var totalBalance = utxos.reduce(function (sum, utxo) {\n            var adaAmount = utxo.amount.find(function (a) {\n              return a.unit === 'lovelace';\n            });\n            return sum + BigInt(adaAmount ? adaAmount.quantity : '0');\n          }, BigInt(0));\n          if (totalBalance < amountNum) {\n            throw new Error(`Insufficient balance. Available: ${totalBalance} lovelace`);\n          }\n          var estimatedFee = this.calculateEstimatedFee(utxos.length, 1);\n          if (totalBalance < amountNum + estimatedFee) {\n            throw new Error(`Insufficient balance for amount + fee. Required: ${amountNum + estimatedFee} lovelace`);\n          }\n          var transaction = {\n            id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            amount: amount,\n            fee: estimatedFee.toString(),\n            from: fromAddress,\n            to: toAddress,\n            status: TransactionStatus.PENDING,\n            timestamp: new Date(),\n            metadata: metadata,\n            isOffline: false\n          };\n          return transaction;\n        } catch (error) {\n          throw new Error(`Failed to build transaction: ${error}`);\n        }\n      });\n      function buildTransaction(_x3, _x4, _x5, _x6) {\n        return _buildTransaction.apply(this, arguments);\n      }\n      return buildTransaction;\n    }())\n  }, {\n    key: \"calculateEstimatedFee\",\n    value: function calculateEstimatedFee(inputCount, outputCount) {\n      var baseFee = BigInt(155381);\n      var inputFee = BigInt(4310);\n      var outputFee = BigInt(4310);\n      return baseFee + BigInt(inputCount) * inputFee + BigInt(outputCount) * outputFee;\n    }\n  }, {\n    key: \"signTransaction\",\n    value: (function () {\n      var _signTransaction = _asyncToGenerator(function* (transaction) {\n        var accountIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        if (!this.rootKey) {\n          throw new Error('Wallet not initialized');\n        }\n        try {\n          var accountKey = this.rootKey.derive(1852 + 0x80000000).derive(1815 + 0x80000000).derive(accountIndex + 0x80000000);\n          var spendingKey = accountKey.derive(0).derive(0);\n          try {\n            var txBuilder = TransactionBuilder.new(TransactionBuilderConfigBuilder.new().fee_algo(LinearFee.new(BigNum.from_str('155381'), BigNum.from_str('4310'))).pool_deposit(BigNum.from_str('500000000')).key_deposit(BigNum.from_str('2000000')).coins_per_utxo_byte(BigNum.from_str('4310')).max_value_size(5000).max_tx_size(16384).build());\n            var utxos = yield this.getUTXOs(transaction.from);\n            for (var utxo of utxos) {\n              var _txHash = TransactionHash.from_bytes(Buffer.from(utxo.tx_hash, 'hex'));\n              var txIndex = utxo.tx_index;\n              var input = TransactionInput.new(_txHash, txIndex);\n              txBuilder.add_input(Address.from_bech32(transaction.from), input, Value.new(BigNum.from_str(utxo.amount[0].quantity)));\n            }\n            var outputAmount = Value.new(BigNum.from_str(transaction.amount));\n            var output = TransactionOutput.new(Address.from_bech32(transaction.to), outputAmount);\n            txBuilder.add_output(output);\n            var txBody = txBuilder.build();\n            var txHash = TransactionHash.from_bytes(txBody.to_bytes());\n            var signature = spendingKey.to_raw_key().sign(txHash.to_bytes());\n            var finalTx = txBuilder.build();\n            var signedTransaction = {\n              body: finalTx,\n              signature: signature,\n              publicKey: spendingKey.to_public().to_raw_key().hash(),\n              txHash: txHash.to_hex(),\n              timestamp: new Date().toISOString()\n            };\n            console.log('Transaction signed successfully:', {\n              txHash: signedTransaction.txHash,\n              timestamp: signedTransaction.timestamp,\n              publicKey: signedTransaction.publicKey.to_hex()\n            });\n            return signedTransaction.body.to_hex();\n          } catch (signingError) {\n            console.error('Transaction signing failed:', signingError);\n            throw new Error(`Transaction signing failed: ${signingError}`);\n          }\n        } catch (error) {\n          throw new Error(`Failed to sign transaction: ${error}`);\n        }\n      });\n      function signTransaction(_x7) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }())\n  }, {\n    key: \"submitTransaction\",\n    value: (function () {\n      var _submitTransaction = _asyncToGenerator(function* (signedTx) {\n        try {\n          var txHash = yield this.apiService.submitTransaction(signedTx);\n          return txHash;\n        } catch (error) {\n          throw new Error(`Failed to submit transaction: ${error}`);\n        }\n      });\n      function submitTransaction(_x8) {\n        return _submitTransaction.apply(this, arguments);\n      }\n      return submitTransaction;\n    }())\n  }, {\n    key: \"getTransactionHistory\",\n    value: (function () {\n      var _getTransactionHistory = _asyncToGenerator(function* (address) {\n        var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n        try {\n          var txList = yield this.apiService.getAddressTransactions(address, count);\n          var transactions = [];\n          for (var txItem of txList) {\n            try {\n              var txDetails = yield this.apiService.getTransaction(txItem.tx_hash);\n              var txUTXOs = yield this.apiService.getTransactionUTXOs(txItem.tx_hash);\n              var isReceived = txUTXOs.outputs.some(function (output) {\n                return output.address === address;\n              });\n              var isSent = txUTXOs.inputs.some(function (input) {\n                return input.address === address;\n              });\n              var amount = '0';\n              var fromAddress = '';\n              var toAddress = '';\n              if (isReceived && !isSent) {\n                var relevantOutput = txUTXOs.outputs.find(function (o) {\n                  return o.address === address;\n                });\n                if (relevantOutput) {\n                  var _txUTXOs$inputs$;\n                  var adaAmount = relevantOutput.amount.find(function (a) {\n                    return a.unit === 'lovelace';\n                  });\n                  amount = adaAmount ? adaAmount.quantity : '0';\n                  toAddress = address;\n                  fromAddress = ((_txUTXOs$inputs$ = txUTXOs.inputs[0]) == null ? void 0 : _txUTXOs$inputs$.address) || '';\n                }\n              } else if (isSent) {\n                var relevantInput = txUTXOs.inputs.find(function (i) {\n                  return i.address === address;\n                });\n                if (relevantInput) {\n                  var _txUTXOs$outputs$;\n                  var _adaAmount = relevantInput.amount.find(function (a) {\n                    return a.unit === 'lovelace';\n                  });\n                  amount = _adaAmount ? _adaAmount.quantity : '0';\n                  fromAddress = address;\n                  toAddress = ((_txUTXOs$outputs$ = txUTXOs.outputs[0]) == null ? void 0 : _txUTXOs$outputs$.address) || '';\n                }\n              }\n              var transaction = {\n                id: txItem.tx_hash,\n                hash: txItem.tx_hash,\n                amount: amount,\n                fee: txDetails.fees,\n                from: fromAddress,\n                to: toAddress,\n                status: TransactionStatus.CONFIRMED,\n                timestamp: new Date(txDetails.block_time * 1000),\n                isOffline: false\n              };\n              transactions.push(transaction);\n            } catch (error) {\n              console.error(`Failed to get details for tx ${txItem.tx_hash}:`, error);\n            }\n          }\n          return transactions;\n        } catch (error) {\n          console.error('Failed to get transaction history:', error);\n          return [];\n        }\n      });\n      function getTransactionHistory(_x9) {\n        return _getTransactionHistory.apply(this, arguments);\n      }\n      return getTransactionHistory;\n    }())\n  }, {\n    key: \"getUTXOs\",\n    value: (function () {\n      var _getUTXOs = _asyncToGenerator(function* (address) {\n        try {\n          return yield this.apiService.getAddressUTXOs(address);\n        } catch (error) {\n          console.error('Failed to get UTXOs:', error);\n          return [];\n        }\n      });\n      function getUTXOs(_x0) {\n        return _getUTXOs.apply(this, arguments);\n      }\n      return getUTXOs;\n    }())\n  }, {\n    key: \"getCurrentNetwork\",\n    value: function getCurrentNetwork() {\n      return this.network;\n    }\n  }, {\n    key: \"switchNetwork\",\n    value: (function () {\n      var _switchNetwork = _asyncToGenerator(function* (networkType) {\n        this.network = networkType === 'mainnet' ? CARDANO_NETWORKS.MAINNET : CARDANO_NETWORKS.TESTNET;\n        this.apiService.setNetwork(networkType);\n      });\n      function switchNetwork(_x1) {\n        return _switchNetwork.apply(this, arguments);\n      }\n      return switchNetwork;\n    }())\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      var networkType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'testnet';\n      if (!CardanoWalletService.instance) {\n        CardanoWalletService.instance = new CardanoWalletService(networkType);\n      }\n      return CardanoWalletService.instance;\n    }\n  }, {\n    key: \"generateMnemonic\",\n    value: function generateMnemonic() {\n      var strength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;\n      return bip39.generateMnemonic(strength);\n    }\n  }, {\n    key: \"validateAddress\",\n    value: function validateAddress(address) {\n      try {\n        Address.from_bech32(address);\n        return true;\n      } catch (_unused) {\n        return false;\n      }\n    }\n  }, {\n    key: \"generatePaymentQR\",\n    value: function generatePaymentQR(address, amount, message) {\n      var qrData = {\n        address: address,\n        amount: amount || '',\n        message: message || '',\n        protocol: 'cardano'\n      };\n      return `cardano:${address}${amount ? `?amount=${amount}` : ''}${message ? `&message=${encodeURIComponent(message)}` : ''}`;\n    }\n  }]);\n}();","map":{"version":3,"names":["bip39","Address","BaseAddress","StakeCredential","Bip32PrivateKey","TransactionBuilder","TransactionOutput","Value","BigNum","LinearFee","TransactionBuilderConfigBuilder","TransactionInput","TransactionHash","CARDANO_NETWORKS","CardanoAPIService","NetworkService","ErrorHandler","TransactionStatus","CardanoWalletService","networkType","arguments","length","undefined","_classCallCheck","network","MAINNET","TESTNET","apiService","getInstance","setNetwork","networkService","errorHandler","_createClass","key","value","_initializeFromMnemonic","_asyncToGenerator","mnemonic","validateMnemonic","Error","seed","mnemonicToSeedSync","rootKey","from_bip39_entropy","Buffer","from","error","console","initializeFromMnemonic","_x","apply","_createAccount","accountIndex","name","accountKey","derive","spendingKey","stakingKey","paymentCredential","from_keyhash","to_public","to_raw_key","hash","stakeCredential","baseAddress","new","networkId","address","to_address","to_bech32","stakeAddress","account","id","balance","isActive","createdAt","Date","createAccount","_getBalance","addressInfo","getAddressInfo","adaAmount","amount","find","a","unit","quantity","getBalance","_x2","_buildTransaction","fromAddress","toAddress","metadata","validateAddress","amountNum","BigInt","utxos","getUTXOs","totalBalance","reduce","sum","utxo","estimatedFee","calculateEstimatedFee","transaction","now","Math","random","toString","substr","fee","to","status","PENDING","timestamp","isOffline","buildTransaction","_x3","_x4","_x5","_x6","inputCount","outputCount","baseFee","inputFee","outputFee","_signTransaction","txBuilder","fee_algo","from_str","pool_deposit","key_deposit","coins_per_utxo_byte","max_value_size","max_tx_size","build","txHash","from_bytes","tx_hash","txIndex","tx_index","input","add_input","from_bech32","outputAmount","output","add_output","txBody","to_bytes","signature","sign","finalTx","signedTransaction","body","publicKey","to_hex","toISOString","log","signingError","signTransaction","_x7","_submitTransaction","signedTx","submitTransaction","_x8","_getTransactionHistory","count","txList","getAddressTransactions","transactions","txItem","txDetails","getTransaction","txUTXOs","getTransactionUTXOs","isReceived","outputs","some","isSent","inputs","relevantOutput","o","_txUTXOs$inputs$","relevantInput","i","_txUTXOs$outputs$","fees","CONFIRMED","block_time","push","getTransactionHistory","_x9","_getUTXOs","getAddressUTXOs","_x0","getCurrentNetwork","_switchNetwork","switchNetwork","_x1","instance","generateMnemonic","strength","_unused","generatePaymentQR","message","qrData","protocol","encodeURIComponent"],"sources":["/Users/sonson/Documents/code/venera/X150-Valkyrie/src/services/CardanoWalletService.ts"],"sourcesContent":["import * as bip39 from 'bip39';\nimport {\n    Address,\n    BaseAddress,\n    StakeCredential,\n    Ed25519KeyHash,\n    Bip32PrivateKey,\n    TransactionBuilder,\n    TransactionOutput,\n    Value,\n    BigNum,\n    LinearFee,\n    TransactionBuilderConfigBuilder,\n    TransactionInput,\n    TransactionWitnessSet,\n    TransactionHash,\n    Vkeywitness\n} from '@emurgo/cardano-serialization-lib-browser';\nimport { CARDANO_NETWORKS } from '../constants/index';\nimport { CardanoAPIService } from './CardanoAPIService';\nimport { NetworkService } from './NetworkService';\nimport { ErrorHandler, ErrorType, ErrorSeverity } from './ErrorHandler';\nimport { WalletAccount, Transaction, TransactionStatus } from '../types/wallet';\n\n/**\n * Service chính để quản lý ví Cardano\n * Xử lý tạo account, tạo transaction, quản lý địa chỉ\n */\nexport class CardanoWalletService {\n    private static instance: CardanoWalletService;\n    private network: typeof CARDANO_NETWORKS.MAINNET | typeof CARDANO_NETWORKS.TESTNET;\n    private rootKey?: Bip32PrivateKey;\n    private apiService: CardanoAPIService;\n    private networkService: NetworkService;\n    private errorHandler: ErrorHandler;\n\n    public static getInstance(networkType: 'mainnet' | 'testnet' = 'testnet'): CardanoWalletService {\n        if (!CardanoWalletService.instance) {\n            CardanoWalletService.instance = new CardanoWalletService(networkType);\n        }\n        return CardanoWalletService.instance;\n    }\n\n    private constructor(networkType: 'mainnet' | 'testnet' = 'testnet') {\n        this.network = networkType === 'mainnet' ? CARDANO_NETWORKS.MAINNET : CARDANO_NETWORKS.TESTNET;\n        this.apiService = CardanoAPIService.getInstance();\n        this.apiService.setNetwork(networkType);\n        this.networkService = NetworkService.getInstance();\n        this.errorHandler = ErrorHandler.getInstance();\n    }\n\n    /**\n     * Khởi tạo ví từ mnemonic\n     * @param mnemonic - Mnemonic phrase (12 hoặc 24 từ)\n     * @returns Success status\n     */\n    async initializeFromMnemonic(mnemonic: string): Promise<boolean> {\n        try {\n            // Validate mnemonic\n            if (!bip39.validateMnemonic(mnemonic)) {\n                throw new Error('Invalid mnemonic phrase');\n            }\n\n            // Generate seed từ mnemonic\n            const seed = bip39.mnemonicToSeedSync(mnemonic);\n\n            // Tạo root private key\n            this.rootKey = Bip32PrivateKey.from_bip39_entropy(\n                Buffer.from(seed),\n                Buffer.from('')\n            );\n\n            return true;\n        } catch (error) {\n            console.error('Failed to initialize wallet:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Tạo mnemonic mới\n     * @param strength - Độ mạnh (128 = 12 từ, 256 = 24 từ)\n     * @returns Mnemonic phrase\n     */\n    static generateMnemonic(strength: 128 | 256 = 128): string {\n        return bip39.generateMnemonic(strength);\n    }\n\n    /**\n     * Tạo account mới\n     * @param accountIndex - Index của account (0, 1, 2...)\n     * @param name - Tên account\n     * @returns WalletAccount object\n     */\n    async createAccount(accountIndex: number = 0, name: string = 'Main Account'): Promise<WalletAccount> {\n        if (!this.rootKey) {\n            throw new Error('Wallet not initialized');\n        }\n\n        try {\n            // Derive account key: m/1852'/1815'/account'\n            const accountKey = this.rootKey\n                .derive(1852 + 0x80000000) // Purpose: 1852' (CIP-1852)\n                .derive(1815 + 0x80000000) // Coin type: 1815' (ADA)\n                .derive(accountIndex + 0x80000000); // Account\n\n            // Derive spending key: m/1852'/1815'/account'/0/0\n            const spendingKey = accountKey\n                .derive(0) // External chain\n                .derive(0); // Address index\n\n            // Derive staking key: m/1852'/1815'/account'/2/0  \n            const stakingKey = accountKey\n                .derive(2) // Staking chain\n                .derive(0); // Address index\n\n            // Tạo payment credential\n            const paymentCredential = StakeCredential.from_keyhash(\n                spendingKey.to_public().to_raw_key().hash()\n            );\n\n            // Tạo stake credential\n            const stakeCredential = StakeCredential.from_keyhash(\n                stakingKey.to_public().to_raw_key().hash()\n            );\n\n            // Tạo base address\n            const baseAddress = BaseAddress.new(\n                this.network.networkId,\n                paymentCredential,\n                stakeCredential\n            );\n\n            const address = baseAddress.to_address().to_bech32();\n            const stakeAddress = stakingKey.to_public().to_raw_key().hash().to_bech32('stake');\n\n            const account: WalletAccount = {\n                id: `account_${accountIndex}`,\n                name,\n                address,\n                stakeAddress,\n                balance: '0',\n                isActive: accountIndex === 0,\n                createdAt: new Date()\n            };\n\n            return account;\n\n        } catch (error) {\n            throw new Error(`Failed to create account: ${error}`);\n        }\n    }\n\n    /**\n     * Lấy balance của một địa chỉ từ Blockfrost API\n     * @param address - Địa chỉ Cardano\n     * @returns Balance trong lovelace\n     */\n    async getBalance(address: string): Promise<string> {\n        try {\n            const addressInfo = await this.apiService.getAddressInfo(address);\n            const adaAmount = addressInfo.amount.find((a: any) => a.unit === 'lovelace');\n            return adaAmount ? adaAmount.quantity : '0';\n\n        } catch (error) {\n            console.error('Failed to get balance:', error);\n            return '0';\n        }\n    }\n\n    /**\n     * Tạo transaction (chưa sign)\n     * @param fromAddress - Địa chỉ gửi\n     * @param toAddress - Địa chỉ nhận  \n     * @param amount - Số lượng ADA (trong lovelace)\n     * @param metadata - Metadata tùy chọn\n     * @returns Transaction object\n     */\n    async buildTransaction(\n        fromAddress: string,\n        toAddress: string,\n        amount: string,\n        metadata?: any\n    ): Promise<Transaction> {\n        try {\n            // Validate addresses\n            if (!CardanoWalletService.validateAddress(fromAddress)) {\n                throw new Error('Invalid sender address');\n            }\n            if (!CardanoWalletService.validateAddress(toAddress)) {\n                throw new Error('Invalid recipient address');\n            }\n\n            // Validate amount\n            const amountNum = BigInt(amount);\n            if (amountNum <= 0) {\n                throw new Error('Amount must be greater than 0');\n            }\n\n            // Get UTXOs for sender address\n            const utxos = await this.getUTXOs(fromAddress);\n            if (utxos.length === 0) {\n                throw new Error('No UTXOs found for sender address');\n            }\n\n            // Calculate total available balance\n            const totalBalance = utxos.reduce((sum, utxo) => {\n                const adaAmount = utxo.amount.find((a: any) => a.unit === 'lovelace');\n                return sum + BigInt(adaAmount ? adaAmount.quantity : '0');\n            }, BigInt(0));\n\n            // Check if sufficient balance\n            if (totalBalance < amountNum) {\n                throw new Error(`Insufficient balance. Available: ${totalBalance} lovelace`);\n            }\n\n            // Calculate estimated fee (simplified)\n            const estimatedFee = this.calculateEstimatedFee(utxos.length, 1);\n\n            // Check if balance covers amount + fee\n            if (totalBalance < (amountNum + estimatedFee)) {\n                throw new Error(`Insufficient balance for amount + fee. Required: ${amountNum + estimatedFee} lovelace`);\n            }\n\n            const transaction: Transaction = {\n                id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                amount,\n                fee: estimatedFee.toString(),\n                from: fromAddress,\n                to: toAddress,\n                status: TransactionStatus.PENDING,\n                timestamp: new Date(),\n                metadata,\n                isOffline: false\n            };\n\n            return transaction;\n\n        } catch (error) {\n            throw new Error(`Failed to build transaction: ${error}`);\n        }\n    }\n\n    /**\n     * Tính toán estimated fee dựa trên số lượng inputs và outputs\n     */\n    private calculateEstimatedFee(inputCount: number, outputCount: number): bigint {\n        // Simplified fee calculation based on Cardano parameters\n        const baseFee = BigInt(155381); // Base fee in lovelace\n        const inputFee = BigInt(4310); // Fee per input\n        const outputFee = BigInt(4310); // Fee per output\n\n        return baseFee + (BigInt(inputCount) * inputFee) + (BigInt(outputCount) * outputFee);\n    }\n\n    /**\n     * Ký transaction offline\n     * @param transaction - Transaction cần ký\n     * @param accountIndex - Index của account để lấy private key\n     * @returns Signed transaction hex\n     */\n    async signTransaction(transaction: Transaction, accountIndex: number = 0): Promise<string> {\n        if (!this.rootKey) {\n            throw new Error('Wallet not initialized');\n        }\n\n        try {\n            // Derive account key: m/1852'/1815'/account'\n            const accountKey = this.rootKey\n                .derive(1852 + 0x80000000) // Purpose: 1852' (CIP-1852)\n                .derive(1815 + 0x80000000) // Coin type: 1815' (ADA)\n                .derive(accountIndex + 0x80000000); // Account\n\n            // Derive spending key: m/1852'/1815'/account'/0/0\n            const spendingKey = accountKey\n                .derive(0) // External chain\n                .derive(0); // Address index\n\n            // Implement actual transaction signing với cardano-serialization-lib\n            try {\n                // 1. Build transaction body\n                const txBuilder = TransactionBuilder.new(\n                    TransactionBuilderConfigBuilder.new()\n                        .fee_algo(LinearFee.new(BigNum.from_str('155381'), BigNum.from_str('4310')))\n                        .pool_deposit(BigNum.from_str('500000000'))\n                        .key_deposit(BigNum.from_str('2000000'))\n                        .coins_per_utxo_byte(BigNum.from_str('4310'))\n                        .max_value_size(5000)\n                        .max_tx_size(16384)\n                        .build()\n                );\n\n                // 2. Add inputs (UTXOs) từ transaction input\n                const utxos = await this.getUTXOs(transaction.from);\n                for (const utxo of utxos) {\n                    const txHash = TransactionHash.from_bytes(Buffer.from(utxo.tx_hash, 'hex'));\n                    const txIndex = utxo.tx_index;\n                    const input = TransactionInput.new(txHash, txIndex);\n                    txBuilder.add_input(Address.from_bech32(transaction.from), input, Value.new(BigNum.from_str(utxo.amount[0].quantity)));\n                }\n\n                // 3. Add outputs từ transaction\n                const outputAmount = Value.new(BigNum.from_str(transaction.amount));\n                const output = TransactionOutput.new(\n                    Address.from_bech32(transaction.to),\n                    outputAmount\n                );\n                txBuilder.add_output(output);\n\n                // 4. Build transaction body\n                const txBody = txBuilder.build();\n\n                // 5. Sign với private key\n                const txHash = TransactionHash.from_bytes(txBody.to_bytes());\n\n                // Tạo signature\n                const signature = spendingKey.to_raw_key().sign(txHash.to_bytes());\n\n                // Build final transaction\n                const finalTx = txBuilder.build();\n\n                // Tạo transaction hoàn chỉnh với signature\n                const signedTransaction = {\n                    body: finalTx,\n                    signature: signature,\n                    publicKey: spendingKey.to_public().to_raw_key().hash(),\n                    txHash: txHash.to_hex(),\n                    timestamp: new Date().toISOString()\n                };\n\n                // Log signed transaction để tracking\n                console.log('Transaction signed successfully:', {\n                    txHash: signedTransaction.txHash,\n                    timestamp: signedTransaction.timestamp,\n                    publicKey: signedTransaction.publicKey.to_hex()\n                });\n\n                // Serialize signed transaction thành CBOR hex để submit\n                return signedTransaction.body.to_hex();\n\n            } catch (signingError) {\n                console.error('Transaction signing failed:', signingError);\n                throw new Error(`Transaction signing failed: ${signingError}`);\n            }\n\n        } catch (error) {\n            throw new Error(`Failed to sign transaction: ${error}`);\n        }\n    }\n\n    /**\n     * Submit transaction lên network qua Blockfrost API\n     * @param signedTx - Signed transaction CBOR hex\n     * @returns Transaction hash\n     */\n    async submitTransaction(signedTx: string): Promise<string> {\n        try {\n            const txHash = await this.apiService.submitTransaction(signedTx);\n            return txHash;\n\n        } catch (error) {\n            throw new Error(`Failed to submit transaction: ${error}`);\n        }\n    }\n\n    /**\n     * Validate địa chỉ Cardano\n     * @param address - Địa chỉ cần validate\n     * @returns true nếu valid\n     */\n    static validateAddress(address: string): boolean {\n        try {\n            Address.from_bech32(address);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Lấy lịch sử giao dịch của một địa chỉ\n     * @param address - Địa chỉ Cardano\n     * @param count - Số lượng transactions\n     * @returns Array of transactions\n     */\n    async getTransactionHistory(address: string, count: number = 50): Promise<Transaction[]> {\n        try {\n            const txList = await this.apiService.getAddressTransactions(address, count);\n\n            const transactions: Transaction[] = [];\n\n            for (const txItem of txList) {\n                try {\n                    const txDetails = await this.apiService.getTransaction(txItem.tx_hash);\n                    const txUTXOs = await this.apiService.getTransactionUTXOs(txItem.tx_hash);\n\n                    // Determine transaction type and amount\n                    const isReceived = txUTXOs.outputs.some((output: any) => output.address === address);\n                    const isSent = txUTXOs.inputs.some((input: any) => input.address === address);\n\n                    let amount = '0';\n                    let fromAddress = '';\n                    let toAddress = '';\n\n                    if (isReceived && !isSent) {\n                        // Pure receive\n                        const relevantOutput = txUTXOs.outputs.find((o: any) => o.address === address);\n                        if (relevantOutput) {\n                            const adaAmount = relevantOutput.amount.find((a: any) => a.unit === 'lovelace');\n                            amount = adaAmount ? adaAmount.quantity : '0';\n                            toAddress = address;\n                            fromAddress = txUTXOs.inputs[0]?.address || '';\n                        }\n                    } else if (isSent) {\n                        // Send (or send to self)\n                        const relevantInput = txUTXOs.inputs.find((i: any) => i.address === address);\n                        if (relevantInput) {\n                            const adaAmount = relevantInput.amount.find((a: any) => a.unit === 'lovelace');\n                            amount = adaAmount ? adaAmount.quantity : '0';\n                            fromAddress = address;\n                            toAddress = txUTXOs.outputs[0]?.address || '';\n                        }\n                    }\n\n                    const transaction: Transaction = {\n                        id: txItem.tx_hash,\n                        hash: txItem.tx_hash,\n                        amount,\n                        fee: txDetails.fees,\n                        from: fromAddress,\n                        to: toAddress,\n                        status: TransactionStatus.CONFIRMED,\n                        timestamp: new Date(txDetails.block_time * 1000),\n                        isOffline: false\n                    };\n\n                    transactions.push(transaction);\n\n                } catch (error) {\n                    console.error(`Failed to get details for tx ${txItem.tx_hash}:`, error);\n                }\n            }\n\n            return transactions;\n\n        } catch (error) {\n            console.error('Failed to get transaction history:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Lấy UTXOs của một địa chỉ\n     * @param address - Địa chỉ Cardano\n     * @returns Array of UTXOs\n     */\n    async getUTXOs(address: string): Promise<any[]> {\n        try {\n            return await this.apiService.getAddressUTXOs(address);\n        } catch (error) {\n            console.error('Failed to get UTXOs:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Tạo QR code data cho transaction request\n     * @param address - Địa chỉ nhận\n     * @param amount - Số lượng ADA\n     * @param message - Message tùy chọn\n     * @returns QR code string\n     */\n    static generatePaymentQR(address: string, amount?: string, message?: string): string {\n        const qrData = {\n            address,\n            amount: amount || '',\n            message: message || '',\n            protocol: 'cardano'\n        };\n\n        return `cardano:${address}${amount ? `?amount=${amount}` : ''}${message ? `&message=${encodeURIComponent(message)}` : ''}`;\n    }\n\n    /**\n     * Lấy thông tin network hiện tại\n     */\n    getCurrentNetwork(): typeof CARDANO_NETWORKS.MAINNET | typeof CARDANO_NETWORKS.TESTNET {\n        return this.network;\n    }\n\n    /**\n     * Chuyển đổi network\n     */\n    async switchNetwork(networkType: 'mainnet' | 'testnet'): Promise<void> {\n        this.network = networkType === 'mainnet' ? CARDANO_NETWORKS.MAINNET : CARDANO_NETWORKS.TESTNET;\n        this.apiService.setNetwork(networkType);\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}