{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nexport var EventBus = function () {\n  function EventBus() {\n    _classCallCheck(this, EventBus);\n    this.listeners = new Map();\n  }\n  return _createClass(EventBus, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      if (!this.listeners.has(event)) {\n        this.listeners.set(event, []);\n      }\n      var eventListeners = this.listeners.get(event);\n      eventListeners.push(callback);\n      return function () {\n        var index = eventListeners.indexOf(callback);\n        if (index > -1) {\n          eventListeners.splice(index, 1);\n        }\n      };\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event, data) {\n      var eventListeners = this.listeners.get(event);\n      if (eventListeners) {\n        eventListeners.forEach(function (callback) {\n          try {\n            callback(data);\n          } catch (error) {\n            console.error(`Error in event listener for ${event}:`, error);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      var eventListeners = this.listeners.get(event);\n      if (eventListeners) {\n        var index = eventListeners.indexOf(callback);\n        if (index > -1) {\n          eventListeners.splice(index, 1);\n        }\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(event) {\n      this.listeners.delete(event);\n    }\n  }, {\n    key: \"clearAll\",\n    value: function clearAll() {\n      this.listeners.clear();\n    }\n  }, {\n    key: \"getListenerCount\",\n    value: function getListenerCount(event) {\n      var eventListeners = this.listeners.get(event);\n      return eventListeners ? eventListeners.length : 0;\n    }\n  }, {\n    key: \"hasListeners\",\n    value: function hasListeners(event) {\n      return this.getListenerCount(event) > 0;\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!EventBus.instance) {\n        EventBus.instance = new EventBus();\n      }\n      return EventBus.instance;\n    }\n  }]);\n}();\nexport var eventBus = EventBus.getInstance();","map":{"version":3,"names":["EventBus","_classCallCheck","listeners","Map","_createClass","key","value","on","event","callback","has","set","eventListeners","get","push","index","indexOf","splice","emit","data","forEach","error","console","off","clear","delete","clearAll","getListenerCount","length","hasListeners","getInstance","instance","eventBus"],"sources":["/Users/sonson/Documents/code/venera/X150-Valkyrie/src/services/EventBus.ts"],"sourcesContent":["type EventCallback = (...args: any[]) => void;\n\ninterface EventMap {\n    'show-toast': { message: string; type: 'success' | 'error' | 'warning' | 'info' };\n    'network-status-changed': { isOnline: boolean; type: string };\n    'transaction-updated': { transactionId: string; status: string };\n    'wallet-locked': { reason: string };\n    'wallet-unlocked': { method: string };\n    'biometric-auth': { success: boolean; type: string };\n}\n\nexport class EventBus {\n    private static instance: EventBus;\n    private listeners: Map<keyof EventMap, EventCallback[]> = new Map();\n\n    static getInstance(): EventBus {\n        if (!EventBus.instance) {\n            EventBus.instance = new EventBus();\n        }\n        return EventBus.instance;\n    }\n\n    /**\n     * Subscribe to an event\n     */\n    on<K extends keyof EventMap>(event: K, callback: (data: EventMap[K]) => void): () => void {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, []);\n        }\n\n        const eventListeners = this.listeners.get(event)!;\n        eventListeners.push(callback);\n\n        // Return unsubscribe function\n        return () => {\n            const index = eventListeners.indexOf(callback);\n            if (index > -1) {\n                eventListeners.splice(index, 1);\n            }\n        };\n    }\n\n    /**\n     * Emit an event\n     */\n    emit<K extends keyof EventMap>(event: K, data: EventMap[K]): void {\n        const eventListeners = this.listeners.get(event);\n        if (eventListeners) {\n            eventListeners.forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error(`Error in event listener for ${event}:`, error);\n                }\n            });\n        }\n    }\n\n    /**\n     * Unsubscribe from an event\n     */\n    off<K extends keyof EventMap>(event: K, callback: EventCallback): void {\n        const eventListeners = this.listeners.get(event);\n        if (eventListeners) {\n            const index = eventListeners.indexOf(callback);\n            if (index > -1) {\n                eventListeners.splice(index, 1);\n            }\n        }\n    }\n\n    /**\n     * Clear all listeners for an event\n     */\n    clear<K extends keyof EventMap>(event: K): void {\n        this.listeners.delete(event);\n    }\n\n    /**\n     * Clear all listeners\n     */\n    clearAll(): void {\n        this.listeners.clear();\n    }\n\n    /**\n     * Get listener count for an event\n     */\n    getListenerCount<K extends keyof EventMap>(event: K): number {\n        const eventListeners = this.listeners.get(event);\n        return eventListeners ? eventListeners.length : 0;\n    }\n\n    /**\n     * Check if event has listeners\n     */\n    hasListeners<K extends keyof EventMap>(event: K): boolean {\n        return this.getListenerCount(event) > 0;\n    }\n}\n\n// Export singleton instance\nexport const eventBus = EventBus.getInstance();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}