{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { CardanoAPIService } from \"./CardanoAPIService\";\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nexport var MultiSignatureService = function () {\n  function MultiSignatureService() {\n    _classCallCheck(this, MultiSignatureService);\n    this.cardanoAPI = CardanoAPIService.getInstance();\n  }\n  return _createClass(MultiSignatureService, [{\n    key: \"createMultiSigWallet\",\n    value: (function () {\n      var _createMultiSigWallet = _asyncToGenerator(function* (name, signers, quorum) {\n        var network = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'mainnet';\n        var description = arguments.length > 4 ? arguments[4] : undefined;\n        try {\n          if (quorum <= 0 || quorum > signers.length) {\n            throw new Error('Invalid quorum value');\n          }\n          var totalWeight = signers.reduce(function (sum, signer) {\n            return sum + signer.weight;\n          }, 0);\n          if (quorum > totalWeight) {\n            throw new Error('Quorum cannot exceed total signer weight');\n          }\n          var address = yield this.generateMultiSigAddress(signers.map(function (s) {\n            return s.publicKey;\n          }));\n          var wallet = {\n            id: `multisig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            name: name,\n            description: description,\n            address: address,\n            signers: signers.map(function (signer, index) {\n              return _objectSpread(_objectSpread({}, signer), {}, {\n                id: `signer_${Date.now()}_${index}`,\n                addedAt: new Date()\n              });\n            }),\n            quorum: quorum,\n            network: network,\n            createdAt: new Date(),\n            lastModified: new Date()\n          };\n          yield this.saveMultiSigWallet(wallet);\n          console.log('Multi-sig wallet created:', wallet.id);\n          return wallet;\n        } catch (error) {\n          throw new Error(`Failed to create multi-sig wallet: ${error}`);\n        }\n      });\n      function createMultiSigWallet(_x, _x2, _x3) {\n        return _createMultiSigWallet.apply(this, arguments);\n      }\n      return createMultiSigWallet;\n    }())\n  }, {\n    key: \"addSigner\",\n    value: (function () {\n      var _addSigner = _asyncToGenerator(function* (walletId, signer) {\n        try {\n          var wallet = yield this.getMultiSigWallet(walletId);\n          if (!wallet) {\n            throw new Error('Wallet not found');\n          }\n          var existingSigner = wallet.signers.find(function (s) {\n            return s.publicKey === signer.publicKey;\n          });\n          if (existingSigner) {\n            throw new Error('Signer already exists');\n          }\n          var newSigner = _objectSpread(_objectSpread({}, signer), {}, {\n            id: `signer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            addedAt: new Date()\n          });\n          wallet.signers.push(newSigner);\n          wallet.lastModified = new Date();\n          yield this.saveMultiSigWallet(wallet);\n          console.log('Signer added to wallet:', walletId);\n          return true;\n        } catch (error) {\n          throw new Error(`Failed to add signer: ${error}`);\n        }\n      });\n      function addSigner(_x4, _x5) {\n        return _addSigner.apply(this, arguments);\n      }\n      return addSigner;\n    }())\n  }, {\n    key: \"removeSigner\",\n    value: (function () {\n      var _removeSigner = _asyncToGenerator(function* (walletId, signerId) {\n        try {\n          var wallet = yield this.getMultiSigWallet(walletId);\n          if (!wallet) {\n            throw new Error('Wallet not found');\n          }\n          var remainingWeight = wallet.signers.filter(function (s) {\n            return s.id !== signerId;\n          }).reduce(function (sum, s) {\n            return sum + s.weight;\n          }, 0);\n          if (remainingWeight < wallet.quorum) {\n            throw new Error('Cannot remove signer: would break quorum requirement');\n          }\n          wallet.signers = wallet.signers.filter(function (s) {\n            return s.id !== signerId;\n          });\n          wallet.lastModified = new Date();\n          yield this.saveMultiSigWallet(wallet);\n          console.log('Signer removed from wallet:', walletId);\n          return true;\n        } catch (error) {\n          throw new Error(`Failed to remove signer: ${error}`);\n        }\n      });\n      function removeSigner(_x6, _x7) {\n        return _removeSigner.apply(this, arguments);\n      }\n      return removeSigner;\n    }())\n  }, {\n    key: \"createMultiSigTransaction\",\n    value: (function () {\n      var _createMultiSigTransaction = _asyncToGenerator(function* (walletId, amount, recipient, metadata) {\n        try {\n          var wallet = yield this.getMultiSigWallet(walletId);\n          if (!wallet) {\n            throw new Error('Wallet not found');\n          }\n          var transaction = yield this.cardanoAPI.buildTransaction({\n            fromAddress: wallet.address,\n            toAddress: recipient,\n            amount: amount,\n            metadata: metadata\n          });\n          var multiSigTx = {\n            id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            walletId: walletId,\n            type: 'send',\n            amount: amount.toString(),\n            recipient: recipient,\n            poolId: undefined,\n            signers: [wallet.address],\n            signatures: [],\n            quorum: 1,\n            status: 'pending',\n            createdAt: new Date(),\n            updatedAt: new Date()\n          };\n          yield this.saveMultiSigTransaction(multiSigTx);\n          console.log('Multi-sig transaction created:', multiSigTx.id);\n          return multiSigTx;\n        } catch (error) {\n          throw new Error(`Failed to create multi-sig transaction: ${error}`);\n        }\n      });\n      function createMultiSigTransaction(_x8, _x9, _x0, _x1) {\n        return _createMultiSigTransaction.apply(this, arguments);\n      }\n      return createMultiSigTransaction;\n    }())\n  }, {\n    key: \"signMultiSigTransaction\",\n    value: (function () {\n      var _signMultiSigTransaction = _asyncToGenerator(function* (transactionId, signerId, privateKey) {\n        try {\n          var transaction = yield this.getMultiSigTransaction(transactionId);\n          if (!transaction) {\n            throw new Error('Transaction not found');\n          }\n          var wallet = yield this.getMultiSigWallet(transaction.walletId);\n          if (!wallet) {\n            throw new Error('Wallet not found');\n          }\n          var signer = wallet.signers.find(function (s) {\n            return s.id === signerId;\n          });\n          if (!signer || !signer.isActive) {\n            throw new Error('Invalid or inactive signer');\n          }\n          var existingSignature = transaction.signatures.find(function (s) {\n            return s.signerId === signerId;\n          });\n          if (existingSignature) {\n            throw new Error('Transaction already signed by this signer');\n          }\n          var signature = yield this.signTransaction(transaction, privateKey);\n          var newSignature = {\n            signerId: signerId,\n            signerName: signer.name,\n            signature: signature,\n            timestamp: new Date(),\n            weight: signer.weight\n          };\n          transaction.signatures.push(newSignature);\n          if (transaction.signatures.length >= transaction.quorum) {\n            transaction.status = 'signed';\n          } else if (transaction.signatures.length > 0) {\n            transaction.status = 'pending';\n          }\n          yield this.saveMultiSigTransaction(transaction);\n          console.log('Transaction signed by signer:', signerId);\n          return true;\n        } catch (error) {\n          throw new Error(`Failed to sign transaction: ${error}`);\n        }\n      });\n      function signMultiSigTransaction(_x10, _x11, _x12) {\n        return _signMultiSigTransaction.apply(this, arguments);\n      }\n      return signMultiSigTransaction;\n    }())\n  }, {\n    key: \"submitMultiSigTransaction\",\n    value: (function () {\n      var _submitMultiSigTransaction = _asyncToGenerator(function* (transactionId) {\n        try {\n          var transaction = yield this.getMultiSigTransaction(transactionId);\n          if (!transaction) {\n            return {\n              success: false,\n              error: 'Transaction not found'\n            };\n          }\n          if (transaction.signatures.length < transaction.quorum) {\n            return {\n              success: false,\n              error: 'Insufficient signatures'\n            };\n          }\n          try {\n            var builtTransaction = yield this.cardanoAPI.buildTransaction({\n              type: transaction.type,\n              amount: transaction.amount,\n              recipient: transaction.recipient,\n              poolId: transaction.poolId,\n              signers: transaction.signers,\n              signatures: transaction.signatures\n            });\n            var result = yield this.cardanoAPI.submitTransaction(transaction.id);\n            if (typeof result === 'string') {\n              transaction.status = 'submitted';\n              transaction.txHash = result;\n              yield this.saveMultiSigTransaction(transaction);\n              return {\n                success: true,\n                txHash: result\n              };\n            } else {\n              return {\n                success: false,\n                error: 'Transaction submission failed'\n              };\n            }\n          } catch (error) {\n            console.error('Transaction building/submission failed:', error);\n            return {\n              success: false,\n              error: 'Transaction failed: ' + error.message\n            };\n          }\n        } catch (error) {\n          console.error('Failed to submit multi-sig transaction:', error);\n          return {\n            success: false,\n            error: 'Submission failed: ' + error.message\n          };\n        }\n      });\n      function submitMultiSigTransaction(_x13) {\n        return _submitMultiSigTransaction.apply(this, arguments);\n      }\n      return submitMultiSigTransaction;\n    }())\n  }, {\n    key: \"getMultiSigWallets\",\n    value: (function () {\n      var _getMultiSigWallets = _asyncToGenerator(function* () {\n        try {\n          var walletsData = yield AsyncStorage.getItem('multisig_wallets');\n          return walletsData ? JSON.parse(walletsData) : [];\n        } catch (error) {\n          console.error('Failed to get multi-sig wallets:', error);\n          return [];\n        }\n      });\n      function getMultiSigWallets() {\n        return _getMultiSigWallets.apply(this, arguments);\n      }\n      return getMultiSigWallets;\n    }())\n  }, {\n    key: \"getMultiSigWallet\",\n    value: (function () {\n      var _getMultiSigWallet = _asyncToGenerator(function* (walletId) {\n        try {\n          var wallets = yield this.getMultiSigWallets();\n          return wallets.find(function (w) {\n            return w.id === walletId;\n          }) || null;\n        } catch (error) {\n          console.error('Failed to get multi-sig wallet:', error);\n          return null;\n        }\n      });\n      function getMultiSigWallet(_x14) {\n        return _getMultiSigWallet.apply(this, arguments);\n      }\n      return getMultiSigWallet;\n    }())\n  }, {\n    key: \"getMultiSigTransactions\",\n    value: (function () {\n      var _getMultiSigTransactions = _asyncToGenerator(function* () {\n        try {\n          var stored = yield AsyncStorage.getItem('multisig_transactions');\n          if (stored) {\n            return JSON.parse(stored);\n          }\n          return [];\n        } catch (error) {\n          console.error('Failed to get multi-sig transactions:', error);\n          return [];\n        }\n      });\n      function getMultiSigTransactions() {\n        return _getMultiSigTransactions.apply(this, arguments);\n      }\n      return getMultiSigTransactions;\n    }())\n  }, {\n    key: \"getMultiSigTransaction\",\n    value: (function () {\n      var _getMultiSigTransaction = _asyncToGenerator(function* (transactionId) {\n        try {\n          var transactionsData = yield AsyncStorage.getItem('multisig_transactions');\n          var transactions = transactionsData ? JSON.parse(transactionsData) : [];\n          return transactions.find(function (t) {\n            return t.id === transactionId;\n          }) || null;\n        } catch (error) {\n          console.error('Failed to get multi-sig transaction:', error);\n          return null;\n        }\n      });\n      function getMultiSigTransaction(_x15) {\n        return _getMultiSigTransaction.apply(this, arguments);\n      }\n      return getMultiSigTransaction;\n    }())\n  }, {\n    key: \"getWalletTransactions\",\n    value: (function () {\n      var _getWalletTransactions = _asyncToGenerator(function* (walletId) {\n        try {\n          var transactionsData = yield AsyncStorage.getItem('multisig_transactions');\n          var transactions = transactionsData ? JSON.parse(transactionsData) : [];\n          return transactions.filter(function (t) {\n            return t.walletId === walletId;\n          });\n        } catch (error) {\n          console.error('Failed to get wallet transactions:', error);\n          return [];\n        }\n      });\n      function getWalletTransactions(_x16) {\n        return _getWalletTransactions.apply(this, arguments);\n      }\n      return getWalletTransactions;\n    }())\n  }, {\n    key: \"generateMultiSigAddress\",\n    value: function () {\n      var _generateMultiSigAddress = _asyncToGenerator(function* (publicKeys) {\n        return `addr1multisig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      });\n      function generateMultiSigAddress(_x17) {\n        return _generateMultiSigAddress.apply(this, arguments);\n      }\n      return generateMultiSigAddress;\n    }()\n  }, {\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator(function* (transaction, privateKey) {\n        return `sig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      });\n      function signTransaction(_x18, _x19) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"saveMultiSigWallet\",\n    value: function () {\n      var _saveMultiSigWallet = _asyncToGenerator(function* (wallet) {\n        try {\n          var wallets = yield this.getMultiSigWallets();\n          var existingIndex = wallets.findIndex(function (w) {\n            return w.id === wallet.id;\n          });\n          if (existingIndex >= 0) {\n            wallets[existingIndex] = wallet;\n          } else {\n            wallets.push(wallet);\n          }\n          yield AsyncStorage.setItem('multisig_wallets', JSON.stringify(wallets));\n        } catch (error) {\n          throw new Error(`Failed to save multi-sig wallet: ${error}`);\n        }\n      });\n      function saveMultiSigWallet(_x20) {\n        return _saveMultiSigWallet.apply(this, arguments);\n      }\n      return saveMultiSigWallet;\n    }()\n  }, {\n    key: \"saveMultiSigTransaction\",\n    value: function () {\n      var _saveMultiSigTransaction = _asyncToGenerator(function* (transaction) {\n        try {\n          var transactionsData = yield AsyncStorage.getItem('multisig_transactions');\n          var transactions = transactionsData ? JSON.parse(transactionsData) : [];\n          var existingIndex = transactions.findIndex(function (t) {\n            return t.id === transaction.id;\n          });\n          if (existingIndex >= 0) {\n            transactions[existingIndex] = transaction;\n          } else {\n            transactions.push(transaction);\n          }\n          yield AsyncStorage.setItem('multisig_transactions', JSON.stringify(transactions));\n        } catch (error) {\n          throw new Error(`Failed to save multi-sig transaction: ${error}`);\n        }\n      });\n      function saveMultiSigTransaction(_x21) {\n        return _saveMultiSigTransaction.apply(this, arguments);\n      }\n      return saveMultiSigTransaction;\n    }()\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!MultiSignatureService.instance) {\n        MultiSignatureService.instance = new MultiSignatureService();\n      }\n      return MultiSignatureService.instance;\n    }\n  }]);\n}();","map":{"version":3,"names":["CardanoAPIService","AsyncStorage","MultiSignatureService","_classCallCheck","cardanoAPI","getInstance","_createClass","key","value","_createMultiSigWallet","_asyncToGenerator","name","signers","quorum","network","arguments","length","undefined","description","Error","totalWeight","reduce","sum","signer","weight","address","generateMultiSigAddress","map","s","publicKey","wallet","id","Date","now","Math","random","toString","substr","index","_objectSpread","addedAt","createdAt","lastModified","saveMultiSigWallet","console","log","error","createMultiSigWallet","_x","_x2","_x3","apply","_addSigner","walletId","getMultiSigWallet","existingSigner","find","newSigner","push","addSigner","_x4","_x5","_removeSigner","signerId","remainingWeight","filter","removeSigner","_x6","_x7","_createMultiSigTransaction","amount","recipient","metadata","transaction","buildTransaction","fromAddress","toAddress","multiSigTx","type","poolId","signatures","status","updatedAt","saveMultiSigTransaction","createMultiSigTransaction","_x8","_x9","_x0","_x1","_signMultiSigTransaction","transactionId","privateKey","getMultiSigTransaction","isActive","existingSignature","signature","signTransaction","newSignature","signerName","timestamp","signMultiSigTransaction","_x10","_x11","_x12","_submitMultiSigTransaction","success","builtTransaction","result","submitTransaction","txHash","message","submitMultiSigTransaction","_x13","_getMultiSigWallets","walletsData","getItem","JSON","parse","getMultiSigWallets","_getMultiSigWallet","wallets","w","_x14","_getMultiSigTransactions","stored","getMultiSigTransactions","_getMultiSigTransaction","transactionsData","transactions","t","_x15","_getWalletTransactions","getWalletTransactions","_x16","_generateMultiSigAddress","publicKeys","_x17","_signTransaction","_x18","_x19","_saveMultiSigWallet","existingIndex","findIndex","setItem","stringify","_x20","_saveMultiSigTransaction","_x21","instance"],"sources":["/Users/sonson/Documents/code/venera/X150-Valkyrie/src/services/MultiSignatureService.ts"],"sourcesContent":["import { CardanoAPIService } from './CardanoAPIService';\nimport { MnemonicEncryptionService } from './MnemonicEncryptionService';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport interface MultiSigWallet {\n    id: string;\n    name: string;\n    description?: string;\n    address: string;\n    signers: MultiSigSigner[];\n    quorum: number;\n    network: 'mainnet' | 'testnet' | 'preview';\n    createdAt: Date;\n    lastModified: Date;\n}\n\nexport interface MultiSigSigner {\n    id: string;\n    name: string;\n    publicKey: string;\n    weight: number;\n    isActive: boolean;\n    addedAt: Date;\n}\n\nexport interface MultiSigTransaction {\n    id: string;\n    walletId: string;\n    type: 'send' | 'delegate' | 'withdraw';\n    amount: string;\n    recipient?: string;\n    poolId?: string;\n    signers: string[];\n    signatures: MultiSigSignature[];\n    quorum: number;\n    status: 'pending' | 'signed' | 'submitted' | 'confirmed' | 'failed';\n    createdAt: Date;\n    updatedAt: Date;\n    txHash?: string;\n}\n\nexport interface MultiSigSignature {\n    signerId: string;\n    signerName: string;\n    signature: string;\n    timestamp: Date;\n    weight: number;\n}\n\n/**\n * Service quản lý Multi-Signature Wallet\n * Hỗ trợ tạo ví nhiều người ký, quản lý signer, và xử lý giao dịch\n */\nexport class MultiSignatureService {\n    private static instance: MultiSignatureService;\n    private cardanoAPI: CardanoAPIService;\n\n    constructor() {\n        this.cardanoAPI = CardanoAPIService.getInstance();\n    }\n\n    static getInstance(): MultiSignatureService {\n        if (!MultiSignatureService.instance) {\n            MultiSignatureService.instance = new MultiSignatureService();\n        }\n        return MultiSignatureService.instance;\n    }\n\n    /**\n     * Tạo Multi-Signature Wallet mới\n     */\n    async createMultiSigWallet(\n        name: string,\n        signers: Omit<MultiSigSigner, 'id' | 'addedAt'>[],\n        quorum: number,\n        network: 'mainnet' | 'testnet' | 'preview' = 'mainnet',\n        description?: string\n    ): Promise<MultiSigWallet> {\n        try {\n            // Validate quorum\n            if (quorum <= 0 || quorum > signers.length) {\n                throw new Error('Invalid quorum value');\n            }\n\n            // Validate signer weights\n            const totalWeight = signers.reduce((sum, signer) => sum + signer.weight, 0);\n            if (quorum > totalWeight) {\n                throw new Error('Quorum cannot exceed total signer weight');\n            }\n\n            // Generate multi-sig address\n            const address = await this.generateMultiSigAddress(signers.map(s => s.publicKey));\n\n            const wallet: MultiSigWallet = {\n                id: `multisig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                name,\n                description,\n                address,\n                signers: signers.map((signer, index) => ({\n                    ...signer,\n                    id: `signer_${Date.now()}_${index}`,\n                    addedAt: new Date()\n                })),\n                quorum,\n                network,\n                createdAt: new Date(),\n                lastModified: new Date()\n            };\n\n            // Save to storage\n            await this.saveMultiSigWallet(wallet);\n\n            console.log('Multi-sig wallet created:', wallet.id);\n            return wallet;\n\n        } catch (error) {\n            throw new Error(`Failed to create multi-sig wallet: ${error}`);\n        }\n    }\n\n    /**\n     * Thêm signer mới vào multi-sig wallet\n     */\n    async addSigner(\n        walletId: string,\n        signer: Omit<MultiSigSigner, 'id' | 'addedAt'>\n    ): Promise<boolean> {\n        try {\n            const wallet = await this.getMultiSigWallet(walletId);\n            if (!wallet) {\n                throw new Error('Wallet not found');\n            }\n\n            // Check if signer already exists\n            const existingSigner = wallet.signers.find(s => s.publicKey === signer.publicKey);\n            if (existingSigner) {\n                throw new Error('Signer already exists');\n            }\n\n            const newSigner: MultiSigSigner = {\n                ...signer,\n                id: `signer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                addedAt: new Date()\n            };\n\n            wallet.signers.push(newSigner);\n            wallet.lastModified = new Date();\n\n            await this.saveMultiSigWallet(wallet);\n            console.log('Signer added to wallet:', walletId);\n\n            return true;\n\n        } catch (error) {\n            throw new Error(`Failed to add signer: ${error}`);\n        }\n    }\n\n    /**\n     * Xóa signer khỏi multi-sig wallet\n     */\n    async removeSigner(walletId: string, signerId: string): Promise<boolean> {\n        try {\n            const wallet = await this.getMultiSigWallet(walletId);\n            if (!wallet) {\n                throw new Error('Wallet not found');\n            }\n\n            // Check if removing signer would break quorum\n            const remainingWeight = wallet.signers\n                .filter(s => s.id !== signerId)\n                .reduce((sum, s) => sum + s.weight, 0);\n\n            if (remainingWeight < wallet.quorum) {\n                throw new Error('Cannot remove signer: would break quorum requirement');\n            }\n\n            wallet.signers = wallet.signers.filter(s => s.id !== signerId);\n            wallet.lastModified = new Date();\n\n            await this.saveMultiSigWallet(wallet);\n            console.log('Signer removed from wallet:', walletId);\n\n            return true;\n\n        } catch (error) {\n            throw new Error(`Failed to remove signer: ${error}`);\n        }\n    }\n\n    /**\n     * Tạo giao dịch multi-sig\n     */\n    async createMultiSigTransaction(\n        walletId: string,\n        amount: string,\n        recipient: string,\n        metadata?: any\n    ): Promise<MultiSigTransaction> {\n        try {\n            const wallet = await this.getMultiSigWallet(walletId);\n            if (!wallet) {\n                throw new Error('Wallet not found');\n            }\n\n            // Build transaction\n            const transaction = await this.cardanoAPI.buildTransaction({\n                fromAddress: wallet.address,\n                toAddress: recipient,\n                amount,\n                metadata\n            });\n\n            const multiSigTx: MultiSigTransaction = {\n                id: `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                walletId,\n                type: 'send',\n                amount: amount.toString(),\n                recipient: recipient,\n                poolId: undefined, // Assuming poolId is not directly available here\n                signers: [wallet.address], // Assuming signers are the wallet's address\n                signatures: [],\n                quorum: 1, // For a single-signer transaction, quorum is 1\n                status: 'pending',\n                createdAt: new Date(),\n                updatedAt: new Date()\n            };\n\n            // Save transaction\n            await this.saveMultiSigTransaction(multiSigTx);\n\n            console.log('Multi-sig transaction created:', multiSigTx.id);\n            return multiSigTx;\n\n        } catch (error) {\n            throw new Error(`Failed to create multi-sig transaction: ${error}`);\n        }\n    }\n\n    /**\n     * Ký giao dịch multi-sig\n     */\n    async signMultiSigTransaction(\n        transactionId: string,\n        signerId: string,\n        privateKey: string\n    ): Promise<boolean> {\n        try {\n            const transaction = await this.getMultiSigTransaction(transactionId);\n            if (!transaction) {\n                throw new Error('Transaction not found');\n            }\n\n            const wallet = await this.getMultiSigWallet(transaction.walletId);\n            if (!wallet) {\n                throw new Error('Wallet not found');\n            }\n\n            const signer = wallet.signers.find(s => s.id === signerId);\n            if (!signer || !signer.isActive) {\n                throw new Error('Invalid or inactive signer');\n            }\n\n            // Check if already signed\n            const existingSignature = transaction.signatures.find(s => s.signerId === signerId);\n            if (existingSignature) {\n                throw new Error('Transaction already signed by this signer');\n            }\n\n            // Sign transaction\n            const signature = await this.signTransaction(transaction, privateKey);\n\n            const newSignature: MultiSigSignature = {\n                signerId,\n                signerName: signer.name,\n                signature,\n                timestamp: new Date(),\n                weight: signer.weight\n            };\n\n            transaction.signatures.push(newSignature);\n\n            // Check if fully signed\n            if (transaction.signatures.length >= transaction.quorum) {\n                transaction.status = 'signed';\n            } else if (transaction.signatures.length > 0) {\n                transaction.status = 'pending';\n            }\n\n            await this.saveMultiSigTransaction(transaction);\n            console.log('Transaction signed by signer:', signerId);\n\n            return true;\n\n        } catch (error) {\n            throw new Error(`Failed to sign transaction: ${error}`);\n        }\n    }\n\n    /**\n     * Submit giao dịch multi-sig đã ký đủ\n     */\n    async submitMultiSigTransaction(transactionId: string): Promise<{ success: boolean; txHash?: string; error?: string }> {\n        try {\n            const transaction = await this.getMultiSigTransaction(transactionId);\n            if (!transaction) {\n                return { success: false, error: 'Transaction not found' };\n            }\n\n            // Check if enough signatures\n            if (transaction.signatures.length < transaction.quorum) {\n                return { success: false, error: 'Insufficient signatures' };\n            }\n\n            // Build transaction\n            try {\n                const builtTransaction = await this.cardanoAPI.buildTransaction({\n                    type: transaction.type,\n                    amount: transaction.amount,\n                    recipient: transaction.recipient,\n                    poolId: transaction.poolId,\n                    signers: transaction.signers,\n                    signatures: transaction.signatures\n                });\n\n                // Submit transaction\n                const result = await this.cardanoAPI.submitTransaction(transaction.id);\n\n                if (typeof result === 'string') {\n                    // Success case - result is txHash\n                    transaction.status = 'submitted';\n                    transaction.txHash = result;\n                    await this.saveMultiSigTransaction(transaction);\n                    return { success: true, txHash: result };\n                } else {\n                    // Error case\n                    return { success: false, error: 'Transaction submission failed' };\n                }\n\n            } catch (error) {\n                console.error('Transaction building/submission failed:', error);\n                return { success: false, error: 'Transaction failed: ' + (error as Error).message };\n            }\n\n        } catch (error) {\n            console.error('Failed to submit multi-sig transaction:', error);\n            return { success: false, error: 'Submission failed: ' + (error as Error).message };\n        }\n    }\n\n    /**\n     * Lấy danh sách multi-sig wallets\n     */\n    async getMultiSigWallets(): Promise<MultiSigWallet[]> {\n        try {\n            const walletsData = await AsyncStorage.getItem('multisig_wallets');\n            return walletsData ? JSON.parse(walletsData) : [];\n        } catch (error) {\n            console.error('Failed to get multi-sig wallets:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Lấy multi-sig wallet theo ID\n     */\n    async getMultiSigWallet(walletId: string): Promise<MultiSigWallet | null> {\n        try {\n            const wallets = await this.getMultiSigWallets();\n            return wallets.find(w => w.id === walletId) || null;\n        } catch (error) {\n            console.error('Failed to get multi-sig wallet:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Lấy tất cả multi-sig transactions\n     */\n    async getMultiSigTransactions(): Promise<MultiSigTransaction[]> {\n        try {\n            const stored = await AsyncStorage.getItem('multisig_transactions');\n            if (stored) {\n                return JSON.parse(stored);\n            }\n            return [];\n        } catch (error) {\n            console.error('Failed to get multi-sig transactions:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Lấy multi-sig transaction theo ID\n     */\n    async getMultiSigTransaction(transactionId: string): Promise<MultiSigTransaction | null> {\n        try {\n            const transactionsData = await AsyncStorage.getItem('multisig_transactions');\n            const transactions = transactionsData ? JSON.parse(transactionsData) : [];\n            return transactions.find((t: MultiSigTransaction) => t.id === transactionId) || null;\n        } catch (error) {\n            console.error('Failed to get multi-sig transaction:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Lấy giao dịch của một wallet\n     */\n    async getWalletTransactions(walletId: string): Promise<MultiSigTransaction[]> {\n        try {\n            const transactionsData = await AsyncStorage.getItem('multisig_transactions');\n            const transactions = transactionsData ? JSON.parse(transactionsData) : [];\n            return transactions.filter((t: MultiSigTransaction) => t.walletId === walletId);\n        } catch (error) {\n            console.error('Failed to get wallet transactions:', error);\n            return [];\n        }\n    }\n\n    // Private methods\n    private async generateMultiSigAddress(publicKeys: string[]): Promise<string> {\n        // This would integrate with cardano-serialization-lib for actual multi-sig address generation\n        // For now, return a placeholder\n        return `addr1multisig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    private async signTransaction(transaction: MultiSigTransaction, privateKey: string): Promise<string> {\n        // This would integrate with cardano-serialization-lib for actual signing\n        // For now, return a placeholder signature\n        return `sig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    private async saveMultiSigWallet(wallet: MultiSigWallet): Promise<void> {\n        try {\n            const wallets = await this.getMultiSigWallets();\n            const existingIndex = wallets.findIndex(w => w.id === wallet.id);\n\n            if (existingIndex >= 0) {\n                wallets[existingIndex] = wallet;\n            } else {\n                wallets.push(wallet);\n            }\n\n            await AsyncStorage.setItem('multisig_wallets', JSON.stringify(wallets));\n        } catch (error) {\n            throw new Error(`Failed to save multi-sig wallet: ${error}`);\n        }\n    }\n\n    private async saveMultiSigTransaction(transaction: MultiSigTransaction): Promise<void> {\n        try {\n            const transactionsData = await AsyncStorage.getItem('multisig_transactions');\n            const transactions = transactionsData ? JSON.parse(transactionsData) : [];\n            const existingIndex = transactions.findIndex((t: MultiSigTransaction) => t.id === transaction.id);\n\n            if (existingIndex >= 0) {\n                transactions[existingIndex] = transaction;\n            } else {\n                transactions.push(transaction);\n            }\n\n            await AsyncStorage.setItem('multisig_transactions', JSON.stringify(transactions));\n        } catch (error) {\n            throw new Error(`Failed to save multi-sig transaction: ${error}`);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}