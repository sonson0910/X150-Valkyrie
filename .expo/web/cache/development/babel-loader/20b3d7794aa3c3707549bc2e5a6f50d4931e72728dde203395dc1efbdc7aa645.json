{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { CardanoAPIService } from \"./CardanoAPIService\";\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nexport var NFTManagementService = function () {\n  function NFTManagementService() {\n    _classCallCheck(this, NFTManagementService);\n    this.cardanoAPI = CardanoAPIService.getInstance();\n  }\n  return _createClass(NFTManagementService, [{\n    key: \"mintNFT\",\n    value: (function () {\n      var _mintNFT = _asyncToGenerator(function* (request) {\n        try {\n          console.log('Minting NFT:', request);\n          if (!request.metadata.name || !request.metadata.name.trim()) {\n            throw new Error('NFT name is required');\n          }\n          if (request.metadata.image) {\n            var imageHash = yield this.calculateImageHash(request.metadata.image);\n            request.metadata.imageHash = imageHash;\n          }\n          var mintTx = yield this.buildNFTMintTransaction(request);\n          var signedTx = yield this.signNFTTransaction(mintTx);\n          var result = yield this.submitNFTTransaction(signedTx);\n          if (result.success) {\n            var assetId = `${request.policyId}${request.assetName}`;\n            var nftAsset = {\n              id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n              assetId: assetId,\n              policyId: request.policyId,\n              assetName: request.assetName,\n              fingerprint: yield this.generateFingerprint(request.policyId, request.assetName),\n              quantity: request.quantity,\n              initialMintTxHash: result.txHash,\n              metadata: request.metadata,\n              createdAt: new Date(),\n              lastUpdated: new Date()\n            };\n            yield this.saveNFTAsset(nftAsset);\n            console.log('NFT minted successfully:', assetId);\n            return {\n              success: true,\n              assetId: assetId,\n              txHash: result.txHash\n            };\n          }\n          return {\n            success: false,\n            error: result.error\n          };\n        } catch (error) {\n          console.error('NFT minting failed:', error);\n          return {\n            success: false,\n            error: `Failed to mint NFT: ${error}`\n          };\n        }\n      });\n      function mintNFT(_x) {\n        return _mintNFT.apply(this, arguments);\n      }\n      return mintNFT;\n    }())\n  }, {\n    key: \"transferNFT\",\n    value: (function () {\n      var _transferNFT = _asyncToGenerator(function* (request) {\n        try {\n          console.log('Transferring NFT:', request);\n          var asset = yield this.getNFTAsset(request.assetId);\n          if (!asset) {\n            throw new Error('NFT asset not found');\n          }\n          if (asset.quantity !== request.quantity) {\n            throw new Error('Insufficient NFT quantity for transfer');\n          }\n          var transferTx = yield this.buildNFTTransferTransaction(request);\n          var signedTx = yield this.signNFTTransaction(transferTx);\n          var result = yield this.submitNFTTransaction(signedTx);\n          if (result.success) {\n            yield this.updateNFTOwnership(request.assetId, request.toAddress, result.txHash);\n            console.log('NFT transferred successfully');\n            return {\n              success: true,\n              txHash: result.txHash\n            };\n          }\n          return {\n            success: false,\n            error: result.error\n          };\n        } catch (error) {\n          console.error('NFT transfer failed:', error);\n          return {\n            success: false,\n            error: `Failed to transfer NFT: ${error}`\n          };\n        }\n      });\n      function transferNFT(_x2) {\n        return _transferNFT.apply(this, arguments);\n      }\n      return transferNFT;\n    }())\n  }, {\n    key: \"getAddressNFTs\",\n    value: (function () {\n      var _getAddressNFTs = _asyncToGenerator(function* (address) {\n        try {\n          var nfts = yield this.cardanoAPI.getAddressAssets(address);\n          var nftAssets = nfts.filter(function (asset) {\n            return asset.quantity === '1';\n          });\n          var formattedNFTs = nftAssets.map(function (asset) {\n            return {\n              id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n              assetId: asset.asset,\n              policyId: asset.policy_id,\n              assetName: asset.asset_name || '',\n              fingerprint: asset.fingerprint,\n              quantity: asset.quantity,\n              initialMintTxHash: asset.initial_mint_tx_hash,\n              metadata: asset.onchain_metadata || asset.metadata,\n              createdAt: new Date(asset.initial_mint_time * 1000),\n              lastUpdated: new Date()\n            };\n          });\n          return formattedNFTs;\n        } catch (error) {\n          console.error('Failed to get address NFTs:', error);\n          return [];\n        }\n      });\n      function getAddressNFTs(_x3) {\n        return _getAddressNFTs.apply(this, arguments);\n      }\n      return getAddressNFTs;\n    }())\n  }, {\n    key: \"getNFTAsset\",\n    value: (function () {\n      var _getNFTAsset = _asyncToGenerator(function* (assetId) {\n        try {\n          var localAsset = yield this.getLocalNFTAsset(assetId);\n          if (localAsset) {\n            return localAsset;\n          }\n          var asset = yield this.cardanoAPI.getAsset(assetId);\n          if (!asset) {\n            return null;\n          }\n          var nftAsset = {\n            id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            assetId: asset.asset,\n            policyId: asset.policy_id,\n            assetName: asset.asset_name || '',\n            fingerprint: asset.fingerprint,\n            quantity: asset.quantity,\n            initialMintTxHash: asset.initial_mint_tx_hash,\n            metadata: asset.onchain_metadata || asset.metadata,\n            createdAt: new Date(asset.initial_mint_time * 1000),\n            lastUpdated: new Date()\n          };\n          yield this.saveNFTAsset(nftAsset);\n          return nftAsset;\n        } catch (error) {\n          console.error('Failed to get NFT asset:', error);\n          return null;\n        }\n      });\n      function getNFTAsset(_x4) {\n        return _getNFTAsset.apply(this, arguments);\n      }\n      return getNFTAsset;\n    }())\n  }, {\n    key: \"getNFTMetadata\",\n    value: (function () {\n      var _getNFTMetadata = _asyncToGenerator(function* (assetId) {\n        try {\n          var asset = yield this.getNFTAsset(assetId);\n          return (asset == null ? void 0 : asset.metadata) || null;\n        } catch (error) {\n          console.error('Failed to get NFT metadata:', error);\n          return null;\n        }\n      });\n      function getNFTMetadata(_x5) {\n        return _getNFTMetadata.apply(this, arguments);\n      }\n      return getNFTMetadata;\n    }())\n  }, {\n    key: \"updateNFTMetadata\",\n    value: (function () {\n      var _updateNFTMetadata = _asyncToGenerator(function* (assetId, metadata) {\n        try {\n          var asset = yield this.getNFTAsset(assetId);\n          if (!asset) {\n            throw new Error('NFT asset not found');\n          }\n          if (metadata.name && metadata.description) {\n            asset.metadata = _objectSpread(_objectSpread(_objectSpread({}, asset.metadata), metadata), {}, {\n              name: metadata.name,\n              description: metadata.description\n            });\n          }\n          asset.lastUpdated = new Date();\n          yield this.saveNFTAsset(asset);\n          console.log('NFT metadata updated:', assetId);\n          return true;\n        } catch (error) {\n          console.error('Failed to update NFT metadata:', error);\n          return false;\n        }\n      });\n      function updateNFTMetadata(_x6, _x7) {\n        return _updateNFTMetadata.apply(this, arguments);\n      }\n      return updateNFTMetadata;\n    }())\n  }, {\n    key: \"getNFTCollection\",\n    value: (function () {\n      var _getNFTCollection = _asyncToGenerator(function* (policyId) {\n        try {\n          var assets = yield this.cardanoAPI.getPolicyAssets(policyId);\n          var nftAssets = assets.filter(function (asset) {\n            return asset.quantity === '1';\n          });\n          var formattedNFTs = nftAssets.map(function (asset) {\n            return {\n              id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n              assetId: asset.asset,\n              policyId: asset.policy_id,\n              assetName: asset.asset_name || '',\n              fingerprint: asset.fingerprint,\n              quantity: asset.quantity,\n              initialMintTxHash: asset.initial_mint_tx_hash,\n              metadata: asset.onchain_metadata || asset.metadata,\n              createdAt: new Date(asset.initial_mint_time * 1000),\n              lastUpdated: new Date()\n            };\n          });\n          return formattedNFTs;\n        } catch (error) {\n          console.error('Failed to get NFT collection:', error);\n          return [];\n        }\n      });\n      function getNFTCollection(_x8) {\n        return _getNFTCollection.apply(this, arguments);\n      }\n      return getNFTCollection;\n    }())\n  }, {\n    key: \"searchNFTs\",\n    value: (function () {\n      var _searchNFTs = _asyncToGenerator(function* (query) {\n        try {\n          var localNFTs = yield this.getAllLocalNFTs();\n          var results = localNFTs.filter(function (nft) {\n            var _nft$metadata, _nft$metadata2;\n            var searchText = `${((_nft$metadata = nft.metadata) == null ? void 0 : _nft$metadata.name) || ''} ${((_nft$metadata2 = nft.metadata) == null ? void 0 : _nft$metadata2.description) || ''}`.toLowerCase();\n            return searchText.includes(query.toLowerCase());\n          });\n          return results;\n        } catch (error) {\n          console.error('Failed to search NFTs:', error);\n          return [];\n        }\n      });\n      function searchNFTs(_x9) {\n        return _searchNFTs.apply(this, arguments);\n      }\n      return searchNFTs;\n    }())\n  }, {\n    key: \"getNFTStatistics\",\n    value: (function () {\n      var _getNFTStatistics = _asyncToGenerator(function* () {\n        try {\n          var localNFTs = yield this.getAllLocalNFTs();\n          var totalNFTs = localNFTs.length;\n          var totalCollections = new Set(localNFTs.map(function (nft) {\n            return nft.policyId;\n          })).size;\n          var totalValue = localNFTs.reduce(function (sum, nft) {\n            return sum + parseFloat(nft.quantity || '0');\n          }, 0);\n          var thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n          var recentMints = localNFTs.filter(function (nft) {\n            return nft.createdAt > thirtyDaysAgo;\n          }).length;\n          return {\n            totalNFTs: totalNFTs,\n            totalCollections: totalCollections,\n            totalValue: totalValue,\n            recentMints: recentMints\n          };\n        } catch (error) {\n          console.error('Failed to get NFT statistics:', error);\n          return {\n            totalNFTs: 0,\n            totalCollections: 0,\n            totalValue: 0,\n            recentMints: 0\n          };\n        }\n      });\n      function getNFTStatistics() {\n        return _getNFTStatistics.apply(this, arguments);\n      }\n      return getNFTStatistics;\n    }())\n  }, {\n    key: \"buildNFTMintTransaction\",\n    value: function () {\n      var _buildNFTMintTransaction = _asyncToGenerator(function* (request) {\n        return {\n          type: 'mint',\n          policyId: request.policyId,\n          assetName: request.assetName,\n          quantity: request.quantity,\n          metadata: request.metadata,\n          fromAddress: request.senderAddress,\n          toAddress: request.recipientAddress\n        };\n      });\n      function buildNFTMintTransaction(_x0) {\n        return _buildNFTMintTransaction.apply(this, arguments);\n      }\n      return buildNFTMintTransaction;\n    }()\n  }, {\n    key: \"buildNFTTransferTransaction\",\n    value: function () {\n      var _buildNFTTransferTransaction = _asyncToGenerator(function* (request) {\n        return {\n          type: 'transfer',\n          assetId: request.assetId,\n          quantity: request.quantity,\n          fromAddress: request.fromAddress,\n          toAddress: request.toAddress,\n          metadata: request.metadata\n        };\n      });\n      function buildNFTTransferTransaction(_x1) {\n        return _buildNFTTransferTransaction.apply(this, arguments);\n      }\n      return buildNFTTransferTransaction;\n    }()\n  }, {\n    key: \"signNFTTransaction\",\n    value: function () {\n      var _signNFTTransaction = _asyncToGenerator(function* (transaction) {\n        return `signed_tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      });\n      function signNFTTransaction(_x10) {\n        return _signNFTTransaction.apply(this, arguments);\n      }\n      return signNFTTransaction;\n    }()\n  }, {\n    key: \"submitNFTTransaction\",\n    value: function () {\n      var _submitNFTTransaction = _asyncToGenerator(function* (signedTx) {\n        try {\n          var result = yield this.cardanoAPI.submitTransaction(signedTx);\n          if (typeof result === 'string') {\n            return {\n              success: true,\n              txHash: result\n            };\n          } else {\n            return {\n              success: false,\n              error: 'Transaction submission failed'\n            };\n          }\n        } catch (error) {\n          return {\n            success: false,\n            error: `Transaction submission failed: ${error}`\n          };\n        }\n      });\n      function submitNFTTransaction(_x11) {\n        return _submitNFTTransaction.apply(this, arguments);\n      }\n      return submitNFTTransaction;\n    }()\n  }, {\n    key: \"calculateImageHash\",\n    value: function () {\n      var _calculateImageHash = _asyncToGenerator(function* (imageUrl) {\n        return `img_hash_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      });\n      function calculateImageHash(_x12) {\n        return _calculateImageHash.apply(this, arguments);\n      }\n      return calculateImageHash;\n    }()\n  }, {\n    key: \"generateFingerprint\",\n    value: function () {\n      var _generateFingerprint = _asyncToGenerator(function* (policyId, assetName) {\n        return `fp_${policyId}_${assetName}_${Date.now()}`;\n      });\n      function generateFingerprint(_x13, _x14) {\n        return _generateFingerprint.apply(this, arguments);\n      }\n      return generateFingerprint;\n    }()\n  }, {\n    key: \"saveNFTAsset\",\n    value: function () {\n      var _saveNFTAsset = _asyncToGenerator(function* (asset) {\n        try {\n          var assets = yield this.getAllLocalNFTs();\n          var existingIndex = assets.findIndex(function (a) {\n            return a.assetId === asset.assetId;\n          });\n          if (existingIndex >= 0) {\n            assets[existingIndex] = asset;\n          } else {\n            assets.push(asset);\n          }\n          yield AsyncStorage.setItem('nft_assets', JSON.stringify(assets));\n        } catch (error) {\n          throw new Error(`Failed to save NFT asset: ${error}`);\n        }\n      });\n      function saveNFTAsset(_x15) {\n        return _saveNFTAsset.apply(this, arguments);\n      }\n      return saveNFTAsset;\n    }()\n  }, {\n    key: \"getLocalNFTAsset\",\n    value: function () {\n      var _getLocalNFTAsset = _asyncToGenerator(function* (assetId) {\n        try {\n          var assets = yield this.getAllLocalNFTs();\n          return assets.find(function (asset) {\n            return asset.assetId === assetId;\n          }) || null;\n        } catch (error) {\n          console.error('Failed to get local NFT asset:', error);\n          return null;\n        }\n      });\n      function getLocalNFTAsset(_x16) {\n        return _getLocalNFTAsset.apply(this, arguments);\n      }\n      return getLocalNFTAsset;\n    }()\n  }, {\n    key: \"getAllLocalNFTs\",\n    value: function () {\n      var _getAllLocalNFTs = _asyncToGenerator(function* () {\n        try {\n          var assetsData = yield AsyncStorage.getItem('nft_assets');\n          return assetsData ? JSON.parse(assetsData) : [];\n        } catch (error) {\n          console.error('Failed to get local NFTs:', error);\n          return [];\n        }\n      });\n      function getAllLocalNFTs() {\n        return _getAllLocalNFTs.apply(this, arguments);\n      }\n      return getAllLocalNFTs;\n    }()\n  }, {\n    key: \"updateNFTOwnership\",\n    value: function () {\n      var _updateNFTOwnership = _asyncToGenerator(function* (assetId, newOwner, txHash) {\n        try {\n          var asset = yield this.getLocalNFTAsset(assetId);\n          if (asset) {\n            asset.lastUpdated = new Date();\n            yield this.saveNFTAsset(asset);\n          }\n        } catch (error) {\n          console.error('Failed to update NFT ownership:', error);\n        }\n      });\n      function updateNFTOwnership(_x17, _x18, _x19) {\n        return _updateNFTOwnership.apply(this, arguments);\n      }\n      return updateNFTOwnership;\n    }()\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!NFTManagementService.instance) {\n        NFTManagementService.instance = new NFTManagementService();\n      }\n      return NFTManagementService.instance;\n    }\n  }]);\n}();","map":{"version":3,"names":["CardanoAPIService","AsyncStorage","NFTManagementService","_classCallCheck","cardanoAPI","getInstance","_createClass","key","value","_mintNFT","_asyncToGenerator","request","console","log","metadata","name","trim","Error","image","imageHash","calculateImageHash","mintTx","buildNFTMintTransaction","signedTx","signNFTTransaction","result","submitNFTTransaction","success","assetId","policyId","assetName","nftAsset","id","Date","now","Math","random","toString","substr","fingerprint","generateFingerprint","quantity","initialMintTxHash","txHash","createdAt","lastUpdated","saveNFTAsset","error","mintNFT","_x","apply","arguments","_transferNFT","asset","getNFTAsset","transferTx","buildNFTTransferTransaction","updateNFTOwnership","toAddress","transferNFT","_x2","_getAddressNFTs","address","nfts","getAddressAssets","nftAssets","filter","formattedNFTs","map","policy_id","asset_name","initial_mint_tx_hash","onchain_metadata","initial_mint_time","getAddressNFTs","_x3","_getNFTAsset","localAsset","getLocalNFTAsset","getAsset","_x4","_getNFTMetadata","getNFTMetadata","_x5","_updateNFTMetadata","description","_objectSpread","updateNFTMetadata","_x6","_x7","_getNFTCollection","assets","getPolicyAssets","getNFTCollection","_x8","_searchNFTs","query","localNFTs","getAllLocalNFTs","results","nft","_nft$metadata","_nft$metadata2","searchText","toLowerCase","includes","searchNFTs","_x9","_getNFTStatistics","totalNFTs","length","totalCollections","Set","size","totalValue","reduce","sum","parseFloat","thirtyDaysAgo","recentMints","getNFTStatistics","_buildNFTMintTransaction","type","fromAddress","senderAddress","recipientAddress","_x0","_buildNFTTransferTransaction","_x1","_signNFTTransaction","transaction","_x10","_submitNFTTransaction","submitTransaction","_x11","_calculateImageHash","imageUrl","_x12","_generateFingerprint","_x13","_x14","_saveNFTAsset","existingIndex","findIndex","a","push","setItem","JSON","stringify","_x15","_getLocalNFTAsset","find","_x16","_getAllLocalNFTs","assetsData","getItem","parse","_updateNFTOwnership","newOwner","_x17","_x18","_x19","instance"],"sources":["/Users/sonson/Documents/code/venera/X150-Valkyrie/src/services/NFTManagementService.ts"],"sourcesContent":["import { CardanoAPIService } from './CardanoAPIService';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport interface NFTAsset {\n    id: string;\n    assetId: string;\n    policyId: string;\n    assetName: string;\n    fingerprint: string;\n    quantity: string;\n    initialMintTxHash: string;\n    metadata?: NFTMetadata;\n    createdAt: Date;\n    lastUpdated: Date;\n}\n\nexport interface NFTMetadata {\n    name: string;\n    description?: string;\n    image?: string;\n    imageHash?: string;\n    files?: NFTFile[];\n    attributes?: NFTAttribute[];\n    version?: string;\n}\n\nexport interface NFTFile {\n    name: string;\n    mediaType: string;\n    src: string;\n    hash?: string;\n}\n\nexport interface NFTAttribute {\n    trait_type: string;\n    value: string;\n    display_type?: string;\n}\n\nexport interface NFTMintRequest {\n    policyId: string;\n    assetName: string;\n    quantity: string;\n    metadata: NFTMetadata;\n    recipientAddress: string;\n    senderAddress: string;\n}\n\nexport interface NFTTransferRequest {\n    assetId: string;\n    quantity: string;\n    fromAddress: string;\n    toAddress: string;\n    metadata?: any;\n}\n\n/**\n * Service quản lý NFT (Non-Fungible Tokens) trên Cardano\n * Hỗ trợ mint, transfer, và quản lý metadata\n */\nexport class NFTManagementService {\n    private static instance: NFTManagementService;\n    private cardanoAPI: CardanoAPIService;\n\n    constructor() {\n        this.cardanoAPI = CardanoAPIService.getInstance();\n    }\n\n    static getInstance(): NFTManagementService {\n        if (!NFTManagementService.instance) {\n            NFTManagementService.instance = new NFTManagementService();\n        }\n        return NFTManagementService.instance;\n    }\n\n    /**\n     * Mint NFT mới\n     */\n    async mintNFT(request: NFTMintRequest): Promise<{ success: boolean; assetId?: string; txHash?: string; error?: string }> {\n        try {\n            console.log('Minting NFT:', request);\n\n            // Validate metadata\n            if (!request.metadata.name || !request.metadata.name.trim()) {\n                throw new Error('NFT name is required');\n            }\n\n            // Validate image if provided\n            if (request.metadata.image) {\n                const imageHash = await this.calculateImageHash(request.metadata.image);\n                request.metadata.imageHash = imageHash;\n            }\n\n            // Build mint transaction\n            const mintTx = await this.buildNFTMintTransaction(request);\n\n            // Sign transaction\n            const signedTx = await this.signNFTTransaction(mintTx);\n\n            // Submit to network\n            const result = await this.submitNFTTransaction(signedTx);\n\n            if (result.success) {\n                // Create NFT asset record\n                const assetId = `${request.policyId}${request.assetName}`;\n                const nftAsset: NFTAsset = {\n                    id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                    assetId,\n                    policyId: request.policyId,\n                    assetName: request.assetName,\n                    fingerprint: await this.generateFingerprint(request.policyId, request.assetName),\n                    quantity: request.quantity,\n                    initialMintTxHash: result.txHash!,\n                    metadata: request.metadata,\n                    createdAt: new Date(),\n                    lastUpdated: new Date()\n                };\n\n                // Save NFT asset\n                await this.saveNFTAsset(nftAsset);\n\n                console.log('NFT minted successfully:', assetId);\n                return {\n                    success: true,\n                    assetId,\n                    txHash: result.txHash\n                };\n            }\n\n            return { success: false, error: result.error };\n\n        } catch (error) {\n            console.error('NFT minting failed:', error);\n            return {\n                success: false,\n                error: `Failed to mint NFT: ${error}`\n            };\n        }\n    }\n\n    /**\n     * Transfer NFT\n     */\n    async transferNFT(request: NFTTransferRequest): Promise<{ success: boolean; txHash?: string; error?: string }> {\n        try {\n            console.log('Transferring NFT:', request);\n\n            // Validate asset exists\n            const asset = await this.getNFTAsset(request.assetId);\n            if (!asset) {\n                throw new Error('NFT asset not found');\n            }\n\n            // Check ownership\n            if (asset.quantity !== request.quantity) {\n                throw new Error('Insufficient NFT quantity for transfer');\n            }\n\n            // Build transfer transaction\n            const transferTx = await this.buildNFTTransferTransaction(request);\n\n            // Sign transaction\n            const signedTx = await this.signNFTTransaction(transferTx);\n\n            // Submit to network\n            const result = await this.submitNFTTransaction(signedTx);\n\n            if (result.success) {\n                // Update asset ownership\n                await this.updateNFTOwnership(request.assetId, request.toAddress, result.txHash!);\n\n                console.log('NFT transferred successfully');\n                return {\n                    success: true,\n                    txHash: result.txHash\n                };\n            }\n\n            return { success: false, error: result.error };\n\n        } catch (error) {\n            console.error('NFT transfer failed:', error);\n            return {\n                success: false,\n                error: `Failed to transfer NFT: ${error}`\n            };\n        }\n    }\n\n    /**\n     * Lấy danh sách NFT của một địa chỉ\n     */\n    async getAddressNFTs(address: string): Promise<NFTAsset[]> {\n        try {\n            // Get from Cardano API\n            const nfts = await this.cardanoAPI.getAddressAssets(address);\n\n            // Filter for NFT assets (quantity = 1)\n            const nftAssets = nfts.filter(asset => asset.quantity === '1');\n\n            // Convert to NFTAsset format\n            const formattedNFTs: NFTAsset[] = nftAssets.map(asset => ({\n                id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                assetId: asset.asset,\n                policyId: asset.policy_id,\n                assetName: asset.asset_name || '',\n                fingerprint: asset.fingerprint,\n                quantity: asset.quantity,\n                initialMintTxHash: asset.initial_mint_tx_hash,\n                metadata: asset.onchain_metadata || asset.metadata,\n                createdAt: new Date(asset.initial_mint_time * 1000),\n                lastUpdated: new Date()\n            }));\n\n            return formattedNFTs;\n\n        } catch (error) {\n            console.error('Failed to get address NFTs:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Lấy NFT asset theo ID\n     */\n    async getNFTAsset(assetId: string): Promise<NFTAsset | null> {\n        try {\n            // Try to get from local storage first\n            const localAsset = await this.getLocalNFTAsset(assetId);\n            if (localAsset) {\n                return localAsset;\n            }\n\n            // Get from Cardano API\n            const asset = await this.cardanoAPI.getAsset(assetId);\n            if (!asset) {\n                return null;\n            }\n\n            // Convert to NFTAsset format\n            const nftAsset: NFTAsset = {\n                id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                assetId: asset.asset,\n                policyId: asset.policy_id,\n                assetName: asset.asset_name || '',\n                fingerprint: asset.fingerprint,\n                quantity: asset.quantity,\n                initialMintTxHash: asset.initial_mint_tx_hash,\n                metadata: asset.onchain_metadata || asset.metadata,\n                createdAt: new Date(asset.initial_mint_time * 1000),\n                lastUpdated: new Date()\n            };\n\n            // Save locally for future use\n            await this.saveNFTAsset(nftAsset);\n\n            return nftAsset;\n\n        } catch (error) {\n            console.error('Failed to get NFT asset:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Lấy metadata của NFT\n     */\n    async getNFTMetadata(assetId: string): Promise<NFTMetadata | null> {\n        try {\n            const asset = await this.getNFTAsset(assetId);\n            return asset?.metadata || null;\n        } catch (error) {\n            console.error('Failed to get NFT metadata:', error);\n            return null;\n        }\n    }\n\n    /**\n     * Cập nhật metadata của NFT\n     */\n    async updateNFTMetadata(assetId: string, metadata: Partial<NFTMetadata>): Promise<boolean> {\n        try {\n            const asset = await this.getNFTAsset(assetId);\n            if (!asset) {\n                throw new Error('NFT asset not found');\n            }\n\n            // Update metadata\n            if (metadata.name && metadata.description) {\n                asset.metadata = {\n                    ...asset.metadata,\n                    ...metadata,\n                    name: metadata.name,\n                    description: metadata.description\n                };\n            }\n            asset.lastUpdated = new Date();\n\n            // Save updated asset\n            await this.saveNFTAsset(asset);\n\n            console.log('NFT metadata updated:', assetId);\n            return true;\n\n        } catch (error) {\n            console.error('Failed to update NFT metadata:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Lấy danh sách NFT collection theo policy ID\n     */\n    async getNFTCollection(policyId: string): Promise<NFTAsset[]> {\n        try {\n            // Get from Cardano API\n            const assets = await this.cardanoAPI.getPolicyAssets(policyId);\n\n            // Filter for NFT assets\n            const nftAssets = assets.filter(asset => asset.quantity === '1');\n\n            // Convert to NFTAsset format\n            const formattedNFTs: NFTAsset[] = nftAssets.map(asset => ({\n                id: `nft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                assetId: asset.asset,\n                policyId: asset.policy_id,\n                assetName: asset.asset_name || '',\n                fingerprint: asset.fingerprint,\n                quantity: asset.quantity,\n                initialMintTxHash: asset.initial_mint_tx_hash,\n                metadata: asset.onchain_metadata || asset.metadata,\n                createdAt: new Date(asset.initial_mint_time * 1000),\n                lastUpdated: new Date()\n            }));\n\n            return formattedNFTs;\n\n        } catch (error) {\n            console.error('Failed to get NFT collection:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Tìm kiếm NFT theo tên hoặc description\n     */\n    async searchNFTs(query: string): Promise<NFTAsset[]> {\n        try {\n            // Get all local NFTs\n            const localNFTs = await this.getAllLocalNFTs();\n\n            // Search in local NFTs\n            const results = localNFTs.filter(nft => {\n                const searchText = `${nft.metadata?.name || ''} ${nft.metadata?.description || ''}`.toLowerCase();\n                return searchText.includes(query.toLowerCase());\n            });\n\n            return results;\n\n        } catch (error) {\n            console.error('Failed to search NFTs:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Lấy NFT statistics\n     */\n    async getNFTStatistics(): Promise<{\n        totalNFTs: number;\n        totalCollections: number;\n        totalValue: number;\n        recentMints: number;\n    }> {\n        try {\n            const localNFTs = await this.getAllLocalNFTs();\n\n            const totalNFTs = localNFTs.length;\n            const totalCollections = new Set(localNFTs.map(nft => nft.policyId)).size;\n            const totalValue = localNFTs.reduce((sum, nft) => sum + parseFloat(nft.quantity || '0'), 0);\n\n            // Count recent mints (last 30 days)\n            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n            const recentMints = localNFTs.filter(nft => nft.createdAt > thirtyDaysAgo).length;\n\n            return {\n                totalNFTs,\n                totalCollections,\n                totalValue,\n                recentMints\n            };\n\n        } catch (error) {\n            console.error('Failed to get NFT statistics:', error);\n            return {\n                totalNFTs: 0,\n                totalCollections: 0,\n                totalValue: 0,\n                recentMints: 0\n            };\n        }\n    }\n\n    // Private methods\n    private async buildNFTMintTransaction(request: NFTMintRequest): Promise<any> {\n        // This would integrate with cardano-serialization-lib for actual transaction building\n        // For now, return a placeholder transaction\n        return {\n            type: 'mint',\n            policyId: request.policyId,\n            assetName: request.assetName,\n            quantity: request.quantity,\n            metadata: request.metadata,\n            fromAddress: request.senderAddress,\n            toAddress: request.recipientAddress\n        };\n    }\n\n    private async buildNFTTransferTransaction(request: NFTTransferRequest): Promise<any> {\n        // This would integrate with cardano-serialization-lib for actual transaction building\n        // For now, return a placeholder transaction\n        return {\n            type: 'transfer',\n            assetId: request.assetId,\n            quantity: request.quantity,\n            fromAddress: request.fromAddress,\n            toAddress: request.toAddress,\n            metadata: request.metadata\n        };\n    }\n\n    private async signNFTTransaction(transaction: any): Promise<string> {\n        // This would integrate with cardano-serialization-lib for actual signing\n        // For now, return a placeholder signed transaction\n        return `signed_tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    private async submitNFTTransaction(signedTx: string): Promise<{ success: boolean; txHash?: string; error?: string }> {\n        try {\n            // Submit via Cardano API\n            const result = await this.cardanoAPI.submitTransaction(signedTx);\n\n            if (typeof result === 'string') {\n                return { success: true, txHash: result };\n            } else {\n                return { success: false, error: 'Transaction submission failed' };\n            }\n        } catch (error) {\n            return { success: false, error: `Transaction submission failed: ${error}` };\n        }\n    }\n\n    private async calculateImageHash(imageUrl: string): Promise<string> {\n        // This would calculate actual image hash\n        // For now, return a placeholder hash\n        return `img_hash_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    private async generateFingerprint(policyId: string, assetName: string): Promise<string> {\n        // This would generate actual fingerprint using cardano-serialization-lib\n        // For now, return a placeholder fingerprint\n        return `fp_${policyId}_${assetName}_${Date.now()}`;\n    }\n\n    private async saveNFTAsset(asset: NFTAsset): Promise<void> {\n        try {\n            const assets = await this.getAllLocalNFTs();\n            const existingIndex = assets.findIndex(a => a.assetId === asset.assetId);\n\n            if (existingIndex >= 0) {\n                assets[existingIndex] = asset;\n            } else {\n                assets.push(asset);\n            }\n\n            await AsyncStorage.setItem('nft_assets', JSON.stringify(assets));\n        } catch (error) {\n            throw new Error(`Failed to save NFT asset: ${error}`);\n        }\n    }\n\n    private async getLocalNFTAsset(assetId: string): Promise<NFTAsset | null> {\n        try {\n            const assets = await this.getAllLocalNFTs();\n            return assets.find(asset => asset.assetId === assetId) || null;\n        } catch (error) {\n            console.error('Failed to get local NFT asset:', error);\n            return null;\n        }\n    }\n\n    private async getAllLocalNFTs(): Promise<NFTAsset[]> {\n        try {\n            const assetsData = await AsyncStorage.getItem('nft_assets');\n            return assetsData ? JSON.parse(assetsData) : [];\n        } catch (error) {\n            console.error('Failed to get local NFTs:', error);\n            return [];\n        }\n    }\n\n    private async updateNFTOwnership(assetId: string, newOwner: string, txHash: string): Promise<void> {\n        try {\n            const asset = await this.getLocalNFTAsset(assetId);\n            if (asset) {\n                // Update ownership information\n                asset.lastUpdated = new Date();\n                await this.saveNFTAsset(asset);\n            }\n        } catch (error) {\n            console.error('Failed to update NFT ownership:', error);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}